#' Container to hold ready-to-plot data for coverage plots
#'
#' This object is generated by calling ? on covDataObjects.
#' 
#' @examples
#' se <- SpliceWiz_example_NxtSE(novelSplicing = TRUE)
#'
#' # Assign annotation of the experimental conditions
#' colData(se)$treatment <- rep(c("A", "B"), each = 3)
#'
#' dataObj <- getCoverageData(
#'     se,
#'     Event = "SE:SRSF3-203-exon4;SRSF3-202-int3",
#'     tracks = colnames(se)
#' )
#' 
#' # covPlotObject uses same parameters as covDataObject, unless arguments
#' # overridden by parameters in getCovPlotObject
#' plotObj_samples <- getCovPlotObject(
#'     dataObj
#' )
#'
#' # Generate group plot
#' plotObj_group <- getCovPlotObject(
#'     dataObj,
#'     condition = "treatment",
#'     tracks = c("A", "B")
#' )
#'
#' @name covPlotObject-class
#' @seealso [getCoverageData]
#' @md
NULL

covPlotObject <- function(
        args = list(),
        cov = list(),
        norm_cov = list(),
        junc = list(),
        cov_stats = list(),
        diff_stats = data.frame(),
        annotation = list()
) {
    obj <- new("covPlotObject",
        args = args,
        cov = cov,
        norm_cov = norm_cov,
        junc = junc,
        cov_stats = cov_stats,
        diff_stats = diff_stats,
        annotation = annotation
    )
    obj
}

#' @describeIn covPlotObject-class Generates a covPlotObject object from a
#'   covDataObject. Allows users to change parameters such as viewing window,
#'   conditions, tracks, and other parameters, for customizing plot parameters
#' @export
getCovPlotObject <- function(
    obj, Event,
    view_start, view_end,
    strand = c("*", "+", "-"),
    tracks, condition,
    ribbon_mode = c("sd", "ci", "sem", "none"),
    diff_mode = c("none", "t-test"),
    reverseGenomeCoords = FALSE,
    condensed = FALSE,
    selected_transcripts = "",
    plot_key_isoforms = FALSE
) {
    args <- obj@args
    if(!missing(view_start))  args[["view_start"]] <- view_start
    if(!missing(view_end))  args[["view_end"]] <- view_end
    args[["reverseGenomeCoords"]] <- reverseGenomeCoords
    if(args[["view_start"]] > args[["view_end"]]) {
        args[["reverseGenomeCoords"]] <- !reverseGenomeCoords
        args[["view_start"]] <- args[["view_start"]] + args[["view_end"]]
        args[["view_end"]] <- args[["view_start"]] - args[["view_end"]]
        args[["view_start"]] <- args[["view_start"]] - args[["view_end"]]
    }

    if(!missing(tracks)) args[["tracks"]] <- tracks
    if(!missing(condition)) {
        args[["condition"]] <- condition
    } else if(missing(tracks)) {
        args[["condition"]] <- NULL
    }

    # sanity check condition / tracks against colData
    colData <- obj@colData
    sampleList <- list()
    samples_to_check <- c()
    if("condition" %in% names(args)) {
        if(args[["condition"]] %in% colnames(colData)) {
            for(cond_elem in args[["tracks"]]) {
                if(any(cond_elem %in% colData[, args[["condition"]]])) {
                    sampleList[[cond_elem]] <- rownames(colData)[
                        colData[, args[["condition"]]] == cond_elem]
                    samples_to_check <- c(samples_to_check,
                        sampleList[[cond_elem]])
                } else {
                    # ignore
                }
            }
        } else {
            .log(paste("In getCovPlotObject,",
                "condition is not a recognised column in colData"
            ))
        }
    } else {
        for(samp in args[["tracks"]]) {
            if(samp %in% rownames(colData)) {
                sampleList[[samp]] <- samp
                samples_to_check <- c(samples_to_check,
                    sampleList[[samp]])
            }
        }
    }
    args[["sampleList"]] <- sampleList

    
    # Junction strand is always same as requested strand
    # But need to check strandedness of RNA-seq data before deciding coverage

    if(
            !missing(strand) && 
            length(strand) == 1 && 
            strand %in% c("*", "+", "-")
    ) {
        args[["strand"]] <- strand
    }

    args[["view_strand_jn"]] <- args[["strand"]]
    if(args[["strand"]] != "*") {
        if(all(obj@normData[["sampleStrand"]][samples_to_check] == -1)) {
            if(args[["strand"]] == "+") {
                args[["view_strand"]] <- "-"
            } else {
                args[["view_strand"]] <- "+"
            }
        }
    } else {
        args[["view_strand"]] <- "*"
    }
    
    if(!missing(Event)) args[["Event"]] <- Event
    
    if(!("Event" %in% names(args)) && "condition" %in% names(args)) {
        .log(paste("In getCovPlotObject,",
            "for plotting by condition, normalizing `Event` must be supplied"
        ))
    }

    cov <- .gCD_getCoverage(obj, args)
    norm_cov <- list()
    if("Event" %in% names(args)) {
         norm_cov <- .gCD_getCoverage(obj, args, normalize = TRUE)
    }

    if("condition" %in% names(args)) {
        # compile junction data
        junc <- .gCD_getPSI(obj, args, norm_cov)
    } else {
        # compile raw junction data
        junc <- .gCD_getJuncRaw(obj, args, cov)
    }
    
    # Plot stats if applicable
    cov_stats <- list()
    diff_stats <- data.table()
    
    ribbon_mode <- match.arg(ribbon_mode)
    if(!is_valid(ribbon_mode)) ribbon_mode <- "none"
    args[["ribbon_mode"]] <- ribbon_mode
    if("condition" %in% names(args)) {
        cov_stats <- .gCD_covStats(norm_cov, ribbon_mode)
        
        diff_mode <- match.arg(diff_mode)
        if(diff_mode == "t-test" & length(args[["sampleList"]]) >= 2) {
            diff_stats <- .gCD_ttest(norm_cov[[1]], norm_cov[[2]])
        }
    }

    # plot relevant annotations
    highlight_gr <- list()
    if(
            "Event" %in% names(args) && 
            args[["Event"]] %in% rownames(obj@normData$rowData)
    ) {
        row <- obj@normData$rowData[args[["Event"]],]
        if (row$EventType %in% c("MXE", "SE")) {
            highlight_gr[[1]] <- coord2GR(c(row$Event1a, row$Event2a))
        } else {
            highlight_gr[[1]] <- coord2GR(row$Event1a)
        }
        if (row$EventType %in% c("MXE")) {
            highlight_gr[[2]] <- coord2GR(c(row$Event1b, row$Event2b))
        } else if (row$EventType %in%  c("SE", "A3SS", "A5SS", "ALE", "AFE")) {
            highlight_gr[[2]] <- coord2GR(row$Event1b)
        }    
    }
    args[["highlight_gr"]] <- highlight_gr

    DTlist <- obj@annotations
    DTlist$reduced.DT <- .gcd_highlight_anno(
        DTlist$reduced.DT, args[["highlight_gr"]]
    )
    
    # Filtering and stacking can be done as later steps
    
    DTlist$reduced.DT <- .gcd_filter_anno(
        DTlist$reduced.DT, DTlist$transcripts.DT,
        selected_transcripts = selected_transcripts,
        gr_expressed_junctions = NULL,
        plot_key_isoforms = plot_key_isoforms
    )

    args[["condensed"]] <- condensed
    DTplotlist <- .gCD_stack_anno(
        DTlist, 
        args[["view_start"]], args[["view_end"]], 
        args[["reverseGenomeCoords"]],
        args[["condensed"]]
    )
    args[["condense_this"]] <- DTplotlist[["condense_this"]]

    
    return(covPlotObject(
        args = args,
        cov = cov,
        norm_cov = norm_cov,
        junc = junc,
        cov_stats = cov_stats,
        diff_stats = diff_stats,
        annotation = DTplotlist
    ))
}


#' @describeIn covPlotObject-class Creates a coverage plot using the stored
#'   data in the covPlotObject
#' @export
setMethod("plotCPO", c(x = "covPlotObject"), function(
    x, plotRanges = NULL,
    tracks = NULL,
    mode = c("raw", "normalized", "stats"),
    stackTracks = FALSE,
    plotJunctions = TRUE,
    plotAnnotations = TRUE,
    plotAnnoSubTrack = TRUE,
    plotDiffTrack = TRUE,
    interactive = FALSE,
    resolution = 10000,
    junctionThreshold = 0.01,
    ...
) {
    # Plot single track
    if(is.null(plotRanges)) {
        plotRanges <- GRanges(
            x@args[["view_chr"]],
            IRanges(
                x@args[["view_start"]], x@args[["view_end"]]
            )
        ) # strand is ignored
    }
    
    if(!is(plotRanges, "GRanges")) .log(paste(
        "In plot() for class covPlotObject,",
        "`plotRanges` must be a GRanges object, or NULL"
    ))

    if(
        !is.null(plotRanges) && is(plotRanges, "GRanges") &&
        any(as.character(seqnames(plotRanges)) != x@args[["view_chr"]])
    ) .log(paste(
        "In plot() for class covPlotObject,",
        "Some elements in `plotRanges` have seqnames that do not match that",
        "of covPlotObject"
    ))

    if(is.null(tracks)) tracks <- x@args[["tracks"]]

    if(!("tracks" %in% names(x@args))) .log(paste(
        "In plot() for class covPlotObject,",
        "attempted to specify `tracks` when there are none in covPlotObject"
    ))

    # Allow `tracks` to be index of tracks to use
    if(
            all(is.numeric(tracks)) && (
                all(tracks > 0) & all(tracks <= length(x@args[["tracks"]]))
            )
    ) {
        tracks <- unique(tracks)
        tracks <- x@args[["tracks"]][tracks]
    }

    if(is(tracks, "list")) {
        for(subtrack %in% tracks) {
            if(!all(subtrack %in% x@args[["tracks"]])) .log(paste(
                "In plot() for class covPlotObject,",
                "some `tracks` are not found in covPlotObject"
            ))
        }
    } else if(!all(tracks %in% x@args[["tracks"]])) .log(paste(
        "In plot() for class covPlotObject,",
        "some `tracks` are not found in covPlotObject"
    ))
    
    if(!is.numeric(resolution) || resolution < 1000) {
        resolution <- 1000
    }
    
    # Structure of plot
    # | 1a || 1b || 1c |
    # | 2a || 2b || 2c |
    # | 3a || 3b || 3c |
    # | pa || pb || pc | - diff track
    # | A  || B  || C  | - annotation subtrack
    # | annotation     | - annotation full track

    covTrack <- list() # nested list
    diffTrack <- list()
    annoSubTrack <- list()
    annoFullTrack <- list() # list of 1
    
    subResolution <- resolution / ceiling(length(plotRanges))
    
    if(stackTracks) {
        for(j in seq_len(length(plotRanges))) {
            range_gr <- plotRanges[j]
            covTrack[[j]] <- .cPO_plotCoverage_multi(
                x, tracks, 
                range_gr = range_gr, 
                resolution = subResolution, 
                interactive = interactive
            )
        }
    } else {
        for(i in seq_len(length(tracks))) {
            covTrack[[i]] <- list()
            track <- tracks[i]
            for(j in seq_len(length(plotRanges))) {
                range_gr <- plotRanges[j]
                covTrack[[i]][[j]] <- .cPO_plotCoverage(
                    x, track, 
                    range_gr = range_gr, 
                    resolution = subResolution, 
                    jnThreshold = junctionThreshold,
                    plotJunctions = plotJunctions,
                    interactive = interactive
                )
            }
        }
    }
    
    
})

.cPO_plotCoverage <- function(
    x, track, 
    range_gr, resolution,
    plotJunctions = TRUE, jnThreshold,
    interactive = FALSE
) {
    # plot mean coverage or raw coverage?
    plotMeanCov <- (length(x@cov_stats) > 0)

    # junction processing is identical
    juncAll <- x@junc
    junc <- x@junc[[track]]
    OL <- findOverlaps(junc, range_gr)
    if(length(from(OL)) > 0) {
        junc <- junc[unique(from(OL))]
    } else {
        junc <- NULL
    }

    if(plotMeanCov) {
        trackName <- paste(x@args[["condition"]], track)
        df <- x@cov_stats[[track]]
        df_sub <- df[,seq_len(2)] # only 2 columns
        if(nrow(df_sub) > 2 * resolution) {
            binwidth <- floor(nrow(df_sub) / resolution)
            df_sub <- .gCD_bin_df(df_sub, binwidth, juncAll)
            
            # subset df by df_sub
            df <- df[df$x %in% round(df_sub$x),]
        }

        dfJn <- .cPO_jn_arcs(
            junc,
            arcHeight = 0.1 * max(df$mean),
            junctionThreshold = jnThreshold * max(df$mean)
        )
    
        if(x@args$ribbon_mode %in% c("ci", "sd", "sem")) {
            df$info <- paste(
                paste0("Coordinate: ", df$x), 
                paste0("Norm-Depth (mean): ", round(df$mean, 4)),
                paste0("Norm-Depth (", x@args$ribbon_mode, "): ", 
                    round(df$var, 4)),
                sep = "\n"
            )
        } else {
            df$info <- paste(
                paste0("Coordinate: ", df$x), 
                paste0("Norm-Depth (mean): ", round(df$mean, 4)),
                sep = "\n"
            )        
        }
    } else {
        trackName <- track
        
        df <- x@cov[[track]]
        if(nrow(df) > 2 * resolution) {
            binwidth <- floor(nrow(df) / resolution)
            df <- .gCD_bin_df(df, binwidth, juncAll)
        }
        df$info <- paste(
            paste0("Coordinate: ", df$x), 
            paste0("Depth: ", df$depth),
            sep = "\n"
        )

        dfJn <- .cPO_jn_arcs(
            junc, 
            arcHeight = 0.1 * max(df$depth),
            junctionThreshold = jnThreshold * max(df$depth)
        )
    }
    df$group <- trackName

    # junc processing - common
    if(plotJunctions) {
        dtJn <- as.data.table(dfJn)
        dtJn <- dtJn[
            get("x") >= start(range_gr) &
            get("x") <= end(range_gr)
        ]
        dtJn[, c("xlabel", "ylabel") := list(
            mean(get("x")), mean(get("y"))), 
            by = "info"
        ]
        dtJn <- unique(dtJn[, 
            c("info", "value", "xlabel", "ylabel"), with = FALSE])
        dfJnSum <- as.data.frame(dtJn)                
    } else {
        dfJnSum <- NA
    }

    # plotting - common
        
    suppressWarnings({
        p <- ggplot(df, aes(text = get("info"))) +
            geom_hline(yintercept = 0)            
    })

    # plot ribbon (group cov only)
    if(plotMeanCov && x@args$ribbon_mode %in% c("ci", "sd", "sem")) {
        p <- p +
            geom_ribbon(data = df, alpha = 0.2,
                aes(
                    x = get("x"), y = get("mean"),
                    ymin = get("mean") - get("var"),
                    ymax = get("mean") + get("var"),
                    group = get("group")
                )
            )
    }
    
    # plot line
    if(plotMeanCov) {
        p <- p + geom_line(aes(
            x = get("x"), y = get("mean"), group = get("group")
        ))
    } else {
        p <- p + geom_line(aes(
            x = get("x"), y = get("depth"), group = get("group")
        ))
    }

    # plot y axis and format
    p <- p + theme_white_legend + labs(y = trackName)

    # plot junctions
    if(plotJunctions) {
        p <- p +
            geom_line(
                data = dfJn, 
                aes(x = get("x"), y = get("yarc"), group = get("info")), 
                color = "darkred"
            ) +
            geom_text(
                data = dfJnSum, 
                aes(
                    x = get("xlabel"), y = get("ylabel"), label = get("value")
                )
            )
        yrange <- c(0, 1.05 * max(
            c(layer_scales(p)$y$range$range[2], dfJn$yarc)
        ))
    } else {
        yrange <- c(0, 1.05 * layer_scales(p)$y$range$range[2])
    }
    
    pl <- NULL

        
    if(interactive) {
        pl <- ggplotly(p, tooltip = "text") %>% 
        layout(
            yaxis = list(
                range = yrange,
                rangemode = "tozero", 
                fixedrange = TRUE
            )
        )
        pl$x$data[[2]]$showlegend <- FALSE
        pl$x$data[[2]]$name <- trackName

        if(plotMeanCov) {
            pl$x$data[[3]]$showlegend <- FALSE
            pl$x$data[[3]]$name <- trackName        
        }

        return(pl)
    } else {
        p <- p +
            theme(axis.title.x = element_blank()) +
            labs(x = "", y = trackName)

        if(x@args[["reverseGenomeCoords"]]) {
            plotViewStart <- end(range_gr)
            plotViewEnd <- start(range_gr)
        } else {
            plotViewStart <- start(range_gr)
            plotViewEnd <- end(range_gr)            
        }

        p <- p + coord_cartesian(
            xlim = c(plotViewStart, plotViewEnd),
            ylim = yrange,
            expand = FALSE
        )     
        
        return(p)
    }
}

.cPO_plotCoverage_multi <- function(
    x, tracks, trackName = "Coverage",
    mode = c("raw", "normalized", "stats"),
    range_gr,
    stacked = FALSE,
    plotJunctions = TRUE, jnThreshold,
    interactive = FALSE
) {
    mode <- match.args(mode)
    if(!is_valid(mode)) mode <- "raw"
    plotMeanCov <- FALSE
    if(mode == "normalized") {
        if(length(x@norm_cov) > 0) {
            plotJunctions <- FALSE
        } else {
            mode <- "raw"
        }
    } else if(mode == "stats") {
        if(length(x@cov_stats) > 0 && all(tracks %in% names(x@cov_stats))) {
            plotMeanCov <- TRUE
        } else {
            mode <- "raw"
        }
    }
    
    # junction processing is identical
    juncAll <- x@junc

    if(missing(trackName)) {
        if(mode == "raw") {
            trackName <- "Coverage"
        } else if(mode == "normalized") {
        
        }
    }

    df_all <- c()
    dfJn_all <- c()
    for(track in tracks) {
        if(plotJunctions) {
            junc <- x@junc[[track]]
            OL <- findOverlaps(junc, range_gr)
            if(length(from(OL)) > 0) {
                junc <- junc[unique(from(OL))]
            } else {
                junc <- NULL
            }        
        } else {
            junc <- NULL
        }

        if(plotMeanCov) {
            groupName <- paste(x@args[["condition"]], track)
            df <- x@cov_stats[[track]]
            df_sub <- df[,seq_len(2)] # only 2 columns

            if(!is.null(junc)) {
                dfJn <- .cPO_jn_arcs(
                    junc,
                    arcHeight = 0.1 * max(df$mean),
                    junctionThreshold = jnThreshold * max(df$mean)
                )            
            }

            if(x@args$ribbon_mode %in% c("ci", "sd", "sem")) {
                df$info <- paste(
                    paste0(groupName, ":"),
                    paste0("Coordinate: ", df$x), 
                    paste0("Norm-Depth (mean): ", round(df$mean, 4)),
                    paste0("Norm-Depth (", x@args$ribbon_mode, "): ", 
                        round(df$var, 4)),
                    sep = "\n"
                )
            } else {
                df$info <- paste(
                    paste0("Coordinate: ", df$x), 
                    paste0("Norm-Depth (mean): ", round(df$mean, 4)),
                    sep = "\n"
                )        
            }
        } else {
            groupName <- track
            
            if(mode == "normalized") {
                df <- x@norm_cov[[track]]                        
            } else {
                df <- x@cov[[track]]            
            }
            
            df$info <- paste(
                paste0(groupName, ":"),
                paste0("Coordinate: ", df$x), 
                paste0("Depth: ", df$depth),
                sep = "\n"
            )

            if(!is.null(junc)) {
                dfJn <- .cPO_jn_arcs(
                    junc, 
                    arcHeight = 0.1 * max(df$depth),
                    junctionThreshold = jnThreshold * max(df$depth)
                )
            }
        }
        df$group <- groupName
        df_all <- rbind(df_all, df)
        
        if(!is.null(junc)) {
            dfJn$group <- groupName
            dfJn_all <- rbind(dfJn_all, dfJn)
        }
    }

    # junc processing - common
    dfJnSum_all <- c()
    if(plotJunctions) {
        dtJn_all <- as.data.table(dfJn_all)
        for(track in tracks) {
            dtJn <- copy(dtJn_all[get("group") == track])
            dtJn <- dtJn[
                get("x") >= start(range_gr) &
                get("x") <= end(range_gr)
            ]
            dtJn[, c("xlabel", "ylabel") := list(
                mean(get("x")), mean(get("y"))), 
                by = "info"
            ]
            dtJn <- unique(dtJn[, 
                c("info", "value", "xlabel", "ylabel"), with = FALSE])
            dtJn$group <- track
            dfJnSum_all <- rbind(dfJnSum_all,
                as.data.frame(dtJn))            
        }
    }

    # plotting - common        
    suppressWarnings({
        p <- ggplot(df_all, aes(text = get("info"))) +
            geom_hline(yintercept = 0)            
    })

    # plot ribbon (group cov only)
    if(plotMeanCov && x@args$ribbon_mode %in% c("ci", "sd", "sem")) {
        p <- p +
            geom_ribbon(data = df_all, alpha = 0.2,
                aes(
                    x = get("x"), y = get("mean"),
                    ymin = get("mean") - get("var"),
                    ymax = get("mean") + get("var"),
                    group = get("group"),
                    fill = get("group")
                )
            )
    }
    
    # plot line
    if(stacked) {
        if(plotMeanCov) {
            p <- p + geom_line(aes(
                x = get("x"), y = get("mean"), 
                group = get("group"), color = get("group")
            ))
        } else {
            p <- p + geom_line(aes(
                x = get("x"), y = get("depth"), 
                group = get("group"), color = get("group")
            ))
        }
    } else {
        if(plotMeanCov) {
            p <- p + geom_line(aes(
                x = get("x"), y = get("mean"), 
                group = get("group")# , color = get("group")
            ))
        } else {
            p <- p + geom_line(aes(
                x = get("x"), y = get("depth"), 
                group = get("group")# , color = get("group")
            ))
        }
    }

    # plot y axis and format
    p <- p + theme_white_legend + labs(y = trackName)

    # plot junctions
    if(plotJunctions) {
        p <- p +
            geom_line(
                data = dfJn_all, 
                aes(x = get("x"), y = get("yarc"), group = get("info")), 
                color = "darkred"
            ) +
            geom_text(
                data = dfJnSum_all, 
                aes(
                    x = get("xlabel"), y = get("ylabel"), label = get("value")
                )
            )
    }
    
    if(!stacked) {
        p <- p + facet_grid(
            rows = vars(get("group")), 
            scales = "free_y", switch = "y"
        )
    }
    
    pl <- NULL
    if(interactive) {
        pl <- ggplotly(p, tooltip = "text") %>% 
        layout(
            yaxis = list(
                range = yrange,
                rangemode = "tozero", 
                fixedrange = TRUE
            )
        )
        pl$x$data[[2]]$showlegend <- FALSE
        pl$x$data[[2]]$name <- trackName

        if(plotMeanCov) {
            pl$x$data[[3]]$showlegend <- FALSE
            pl$x$data[[3]]$name <- trackName        
        }

        return(pl)
    } else {
        p <- p +
            theme(axis.title.x = element_blank()) +
            labs(x = "", y = trackName)

        if(x@args[["reverseGenomeCoords"]]) {
            plotViewStart <- end(range_gr)
            plotViewEnd <- start(range_gr)
        } else {
            plotViewStart <- start(range_gr)
            plotViewEnd <- end(range_gr)            
        }

        p <- p + coord_cartesian(
            xlim = c(plotViewStart, plotViewEnd),
            ylim = yrange,
            expand = FALSE
        )     
        
        return(p)
    }
}


.cPO_jn_arcs <- function(
        junc, 
        arcHeight = 0,
        junctionThreshold = 0
) {
    if(is.null(junc)) return(NA)
    
    df <- data.frame(
        juncName = paste0(
            seqnames(junc), ":",
            start(junc), "-", end(junc), "/", strand(junc)
        ),
        juncStart = start(junc) - 1,
        juncEnd = end(junc) + 1
    )

    final <- c()
    isMean <- ("mean" %in% names(mcols(junc)))
    for(i in seq_len(length(junc))) {
        count <- countsd <- 0
        if(isMean) {
            count <- mcols(junc)$mean[i]
            countsd <- mcols(junc)$sd[i]
        } else {
            count <- mcols(junc)$count[i]
        }
        if(count >= junctionThreshold) {
            leftY <- mcols(junc)$leftCoordHeight[i]
            rightY <- mcols(junc)$rightCoordHeight[i]
            leftX <- df$juncStart[i]
            rightX <- df$juncEnd[i]
            juncName <- df$juncName[i]
            
            outdf <- data.frame(
                x = seq(leftX, rightX, length.out = 90),
                y = seq(leftY, rightY, length.out = 90)
            )
            outdf$yarc <- outdf$y + sinpi(seq(0,1,length.out = 90)) * arcHeight
            outdf$coord <- juncName

            if(isMean) {
                outdf$value <- paste0(
                    round(100 * count, 1), "+/-", 
                    round(100 * countsd, 1), " %"
                )
                outdf$info <- paste(
                    paste0("Junction: ", juncName),
                    paste0("PSI: ", outdf$value),
                    sep = "\n"
                )
            } else {
                outdf$value <- count            
                outdf$info <- paste(
                    paste0("Junction: ", juncName),
                    paste0("Depth: ", count),
                    sep = "\n"
                )
            }
            final <- rbind(final, outdf)
        }
    }
    return(final)
}
