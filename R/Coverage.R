# Exported wrapper functions to plot coverage plots from command line:

#' RNA-seq Coverage Plots and Genome Tracks
#'
#' Generate plotly / ggplot RNA-seq genome and coverage plots from command line.
#' For some quick working examples, see the Examples section below.
#'
#' @details
#' In RNA sequencing, alignments to spliced transcripts will "skip" over genomic
#' regions of introns. This can be illustrated in a plot using a horizontal
#' genomic axis, with the vertical axis representing the number of alignments
#' covering each nucleotide. As a result, the coverage "hills" represent the
#' expression of exons, and "valleys" to introns.
#'
#' Different alternatively-spliced isoforms thus produce different coverage
#' patterns. The change in the coverage across an alternate exon relative to its
#' constitutively-included flanking exons, for example, represents its
#' alternative inclusion or skipping.  Similarly, elevation of intron
#' valleys represent increased intron retention.
#'
#' With multiple replicates per sample, coverage is dependent on
#' library size and gene expression. To compare
#' alternative splicing ratios, normalisation of the coverage of the alternate
#' exon (or alternatively retained intron) relative to their constitutive
#' flanking exons, is required. There is no established method for this
#' normalisation, and can be confounded in situations where flanking elements
#' are themselves alternatively spliced.
#'
#' SpliceWiz performs this coverage normalisation using the same method as its
#' estimate of spliced / intronic transcript abundance using the `SpliceOver`
#' method (see details section in [collateData]). This normalisation can be
#' applied to correct for library size and gene expression differences between
#' samples of the same experimental condition. After normalisation, mean and
#' variance of coverage can be computed as ratios relative to total transcript
#' abundance. This method can visualise alternatively included genomic regions
#' including casette exons, alternate splice site usage, and intron retention.
#'
#' `plotCoverage` generates plots showing depth of alignments to
#' the genomic axis. Plots can be generated for individual samples or samples
#' grouped by experimental conditions. In the latter, mean and 95% confidence
#' intervals are shown.
#'
#' `plotGenome` generates genome transcript tracks only. Protein-coding
#' regions are denoted by thick rectangles, whereas non-protein coding
#' transcripts or untranslated regions are denoted with thin rectangles.
#' Introns are denoted as lines.
#'
#' @param se  A \linkS4class{NxtSE} object, created by [makeSE].
#'   COV files must be linked to the NxtSE object. To do this, see the example
#'   in [makeSE]. Required by `plotCoverage`. Not required by `plotGenome` if
#'   `reference_path` is supplied.
#' @param reference_path The path of the reference generated by
#'   [Build-Reference-methods]. Required by `plotGenome` if a 
#'   \linkS4class{NxtSE} object is not specified.
#' @param Event The `EventName` of the IR / alternative splicing event to be
#'   displayed. Use `rownames(se)` to display a list of valid events.
#' @param Gene Whether to use the range for the given `Gene`. If given,
#'   overrides `Event` (but `Event` or `norm_event` will be used to normalise by
#'  condition). Valid `Gene` entries include gene_id (Ensembl ID) or gene_name
#'  (Gene Symbol).
#' @param seqname,start,end The chromosome (string) and genomic `start/end`
#'   coordinates (numeric) of the region to display. If present, overrides both
#'   `Event` and `Gene`. E.g. for a given region of chr1:10000-11000,
#'   use the parameters: `seqname = "chr1", start = 10000, end = 11000`
#' @param coordinates A string specifying genomic coordinates can be given
#'   instead of `seqname,start,end`. Must be of the format "chr:start-end", e.g.
#'   "chr1:10000-11000"
#' @param strand Whether to show coverage of both strands "*" (default), or
#'   from the "+" or "-" strand only.
#' @param zoom_factor Zoom out from event. Each level of zoom zooms out by a
#'   factor of 3. E.g. for a query region of chr1:10000-11000, if a
#'   `zoom_factor` of 1.0 is given, chr1:99000-12000 will be displayed.
#' @param tracks The names of individual samples,
#'   or the names of the different conditions to be plotted. For the latter, set
#'   `condition` to the specified condition category.
#' @param track_names The names of the tracks to be displayed. If omitted, the
#'   track_names will default to the input in `tracks`
#' @param ribbon_mode (default `"sd"`) Whether coverage ribbons signify 
#'   standard deviation `"sd"`, 95% confidence interval `"ci"`,
#'   standard error of the mean `"sem"`,
#'   or none `"none"`. Only applicable when `condition` is set.
#' @param condition To display normalised coverage per condition, set this to
#'   the condition category. If omitted, `tracks` are assumed to refer to the
#'   names of individual samples.
#' @param selected_transcripts (Optional) A vector containing transcript ID
#'   or transcript names of transcripts
#'   to be displayed on the gene annotation track. Useful to remove minor
#'   isoforms that are not relevant to the samples being displayed.
#' @param plotJunctions (default `FALSE`) If `TRUE`, sashimi plot junction arcs
#'   are plotted. Currently only implemented for plots of individual samples.
#' @param junctionThreshold (default `0.01`) The threshold expression of
#'   junction reads below which junction arcs will be omitted. This removes
#'   cluttering of junction arcs from lowly-expressed (rare) junctions.
#'   For individual
#'   tracks, this is the fraction of coverage height. For by-condition
#'   tracks, this is a PSI threshold.
#' @param plot_key_isoforms (default `FALSE`) If `TRUE`, only 
#'   transcripts involved in the selected `Event` or pair of `Event`s will be
#'   displayed.
#' @param condense_tracks (default `FALSE`) Whether to collapse the
#'   transcript track annotations by gene.
#' @param stack_tracks (default `FALSE`) Whether to graph all the conditions on
#'   a single coverage track. If set to `TRUE`, each condition will be displayed
#'   in a different colour on the same track. Ignored if `condition` is not set.
#' @param t_test (default `FALSE`) Whether to perform a pair-wise T-test.
#'   Only used if there are TWO condition tracks.
#' @param norm_event Whether to normalise by an event different to that given
#'   in "Event". The difference between this and Event is that the genomic
#'   coordinates can be centered around a different `Event`, `Gene` or region
#'   as given in `seqname/start/end`. If `norm_event` is different to
#'   `Event`, `norm_event` will be used for normalisation and `Event` will be
#'   used to define the genomic coordinates of the viewing window. `norm_event`
#'   is required if `Event` is not set and `condition` is set.
#' @param bases_flanking (Default = `100`) How many bases flanking the zoomed
#'    window. Useful when
#'    used in conjunction with zoom_factor == 0. E.g. for a given region of
#'    chr1:10000-11000, if `zoom_factor = 0` and `bases_flanking = 100`, the
#'    region chr1:9900-11100 will be displayed.
#' @param p_obj In `as_ggplot_cov`, takes the output of `plotCoverage` and
#'   plots all tracks in a static plot using `ggarrange` function of the
#'   `egg` package. Requires `egg` package to be installed.
#' @param includeCalculations (default `FALSE`) Whether per-coordinate coverage
#'   data should be returned as output. If `TRUE`, the final returned list
#'   includes a third object `"calc"` which is a data frame containing
#'   coverage data.
#' @param reverseGenomeCoords (default `FALSE`) Whether to reverse the genomic
#'   coordinates - helpful for intuitive plotting of negative-strand genes
#'
#' @return A list containing two objects (`final_plot` and `ggplot`). 
#'   `final_plot` is the plotly object.
#'   `ggplot` is a list of ggplot tracks, with:
#'
#' * `ggplot[[n]]` is the nth track (where n = 1, 2, 3 or 4).
#' * `ggplot[[5]]` contains the T-test track if one is generated.
#' * `ggplot[[6]]` always contains the genome track.
#' A static plot can be generated using the `as_ggplot_cov` function.
#' @examples
#' se <- SpliceWiz_example_NxtSE(novelSplicing = TRUE)
#'
#' # Assign annotation of the experimental conditions
#' colData(se)$treatment <- rep(c("A", "B"), each = 3)
#'
#' # Verify that the COV files are linked to the NxtSE object:
#' covfile(se)
#'
#' # Plot the genome track only, with specified gene:
#' p <- plotGenome(se, Gene = "SRSF3")
#' p$ggplot
#'
#' # View the genome track, specifying a genomic region via coordinates:
#' p <- plotGenome(se, coordinates = "chrZ:10000-20000")
#' p$ggplot
#'
#' # Return a list of ggplot and plotly objects, also plotting junction counts
#' p <- plotCoverage(
#'     se = se,
#'     Event = "SE:SRSF3-203-exon4;SRSF3-202-int3",
#'     tracks = colnames(se)[1:4], plotJunctions = TRUE
#' )
#'
#' # Display as a a static ggplot (requires the `egg` package to be installed):
#' as_ggplot_cov(p)
#'
#' # Display the plotly-based interactive Coverage plot:
#' p$final_plot
#'
#' # Plot by condition "treatment", including provisional PSIs
#' p <- plotCoverage(
#'     se = se,
#'     Event = "SE:SRSF3-203-exon4;SRSF3-202-int3",
#'     tracks = c("A", "B"), condition = "treatment", plotJunctions = TRUE
#' )
#' as_ggplot_cov(p)
#'
#' # As above, but stack all traces into the same track
#' # - NB: plotJunctions is disabled when `stack_tracks = TRUE`
#' p <- plotCoverage(
#'     se = se,
#'     Event = "SE:SRSF3-203-exon4;SRSF3-202-int3",
#'     tracks = c("A", "B"), condition = "treatment", stack_tracks = TRUE
#' )
#' as_ggplot_cov(p)
#'
#' # Select only transcripts involved in the selected alternative splicing event
#' p <- plotCoverage(
#'     se = se,
#'     Event = "SE:SRSF3-203-exon4;SRSF3-202-int3",
#'     tracks = colnames(se)[1:4],
#'     plot_key_isoforms = TRUE
#' )
#' as_ggplot_cov(p)
#' @name plotCoverage
#' @md
NULL

#' @describeIn plotCoverage generates plots showing depth of alignments to
#' the genomic axis. Plots can be generated for individual samples or samples
#' grouped by experimental conditions. In the latter, mean and 95% confidence
#' intervals are shown.
#' @export
plotCoverage <- function(
        se,
        Event, Gene,
        seqname, start, end, # Optional
        coordinates,
        strand = c("*", "+", "-"),
        zoom_factor, bases_flanking = 100,
        tracks,
        track_names = tracks,
        condition,
        ribbon_mode = c("sd", "ci", "sem", "none"),
        selected_transcripts,
        reverseGenomeCoords = FALSE,
        plotJunctions = FALSE,
        junctionThreshold = 0.01,
        plot_key_isoforms = FALSE,
        condense_tracks = FALSE,
        stack_tracks = FALSE,
        t_test = FALSE,
        includeCalculations = FALSE,
        norm_event
) {
    if ((missing(seqname) | missing(start) | missing(end)) &
        !missing(coordinates)) {
        gr <- coord2GR(coordinates)
        seqname <- tstrsplit(coordinates, split = ":", fixed=TRUE)[[1]]
        rangetxt <- tstrsplit(coordinates, split = ":", fixed=TRUE)[[2]]
        rangetxt <- tstrsplit(rangetxt, split = "/", fixed=TRUE)[[1]]
        start <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[1]])
        end <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[2]])
    }
    # Validate given arguments
    .plot_cov_validate_args(se, tracks, condition, Event, Gene,
        seqname, start, end, bases_flanking)
    cov_data <- ref(se)
    strand <- match.arg(strand)
    if (strand == "") strand <- "*"
    ribbon_mode <- match.arg(ribbon_mode)
    # Work out viewing coordinates based on given request
    coords <- .plotCoverage_determine_params(
        se, Event, Gene,
        seqname, start, end, zoom_factor, bases_flanking
    )
    if (missing(norm_event)) {
        if (!missing(Event)) {
            norm_event <- Event
        } else {
            norm_event <- ""
        }
    }
    if (missing(condition)) condition <- ""
    if (condition != "" & norm_event == "") {
        .log(paste("If `condition` is set,",
            "you must provide a valid `norm_event` or `Event`,",
            "otherwise per-condition depth normalization cannot be performed"
        ))
    }

    if(!is.numeric(junctionThreshold)) junctionThreshold <- 0.01

    args <- list(
        view_chr = coords$view_chr, view_start = coords$view_start,
        view_end = coords$view_end, view_strand = strand,
        norm_event = norm_event, condition = condition,
        tracks = as.list(tracks), track_names = track_names,
        ribbon_mode = ribbon_mode, 
        se = se, avail_files = covfile(se),
        transcripts = cov_data$transcripts, elems = cov_data$elements,
        stack_tracks = stack_tracks,
        plot_key_isoforms = plot_key_isoforms,
        graph_mode = "Pan", conf.int = 0.95,
        t_test = t_test, condensed = condense_tracks,
        plotJunctions = plotJunctions, junctionThreshold = junctionThreshold,
        includeCalculations = includeCalculations,
        reverseGenomeCoords = reverseGenomeCoords
    )

    args[["highlight_events"]] <- .plotCoverage_highlight_events(se, norm_event)

    if (!missing(selected_transcripts))
        args[["selected_transcripts"]] <- selected_transcripts

    p <- do.call(.plot_cov_fn, args)
    # for(i in seq_len(length(p$ggplot) - 1)) {
        # if(!is.null(p$ggplot[[i]])) {
            # p$ggplot[[i]] <- p$ggplot[[i]] +
                # coord_cartesian(
                    # xlim = c(coords$view_start, coords$view_end),
                    # expand = FALSE)
        # }
    # }

    return(p)
}


#' @describeIn plotCoverage Generates a plot of transcripts within a given
#'   genomic region, or belonging to a specified gene
#' @export
plotGenome <- function(se, reference_path,
    Gene, seqname, start, end, coordinates, zoom_factor, bases_flanking = 100,
    selected_transcripts, reverseGenomeCoords = FALSE,
    condense_tracks = FALSE
) {
    if (missing(se) & missing(reference_path))
        .log("Either one of `reference_path` or `se` is required")

    if (missing(se)) {
        if (!file.exists(file.path(reference_path, "cov_data.Rds")))
            .log("Given reference_path is not a valid SpliceWiz reference")

        cov_data <- readRDS(file.path(reference_path, "cov_data.Rds"))
    } else {
        if (!is(se, "NxtSE")) .log("`se` must be a NxtSE object")
        cov_data <- ref(se)
    }
    if ((missing(seqname) | missing(start) | missing(end)) &
        !missing(coordinates)) {
        gr <- coord2GR(coordinates)
        seqname <- tstrsplit(coordinates, split = ":", fixed=TRUE)[[1]]
        rangetxt <- tstrsplit(coordinates, split = ":", fixed=TRUE)[[2]]
        rangetxt <- tstrsplit(rangetxt, split = "/", fixed=TRUE)[[1]]
        start <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[1]])
        end <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[2]])
    }
    .plot_cov_validate_args_loci(cov_data,
        Gene = Gene, seqname = seqname, start = start, end = end)

    coords <- .plotGenome_determine_params(
        cov_data, Gene, seqname, start, end, zoom_factor, bases_flanking
    )

    args <- list(
        view_chr = coords$view_chr, view_start = coords$view_start,
        view_end = coords$view_end,
        transcripts = cov_data$transcripts, elems = cov_data$elements,
        condensed = condense_tracks,
        reverseGenomeCoords = reverseGenomeCoords
    )
    if (!missing(selected_transcripts))
        args$selected_transcripts <- selected_transcripts

    p_ref <- do.call(.plot_view_ref_fn, args)
    # Remove legend for p_ref; this causes trouble for plotly
    for (i in seq_len(length(p_ref$pl$x$data))) {
        p_ref$pl$x$data[[i]]$showlegend <- FALSE
    }
    p_ref$gp <- p_ref$gp +
        theme(legend.position = "none") +
        labs(x = paste("Chromosome", coords$view_chr))
    
    final <- list(ggplot = p_ref$gp,
        final_plot = p_ref$pl)
    return(final)
}

#' @describeIn plotCoverage Coerce the `plotCoverage()` output as a vertically
#'   stacked ggplot, using egg::ggarrange
#' @export
as_ggplot_cov <- function(p_obj) {
    .check_package_installed("egg")
    if (
        !("ggplot" %in% names(p_obj)) ||
        !is(p_obj$ggplot[[1]], "ggplot") ||
        !is(p_obj$ggplot[[6]], "ggplot")
    ) .log("Given object is not a recognised plotCoverage output object")

    plot_tracks <- p_obj$ggplot[
        unlist(lapply(p_obj$ggplot, function(x) !is.null(x)))]
    
    # Catch any unexpected errors
    tryCatch({
        egg::ggarrange(plots = plot_tracks, ncol = 1)
    }, error = function(x) {
        .log(x, "message")
        return(NULL)
    })
}

#' Calls SpliceWiz's C++ function to retrieve coverage from a COV file
#'
#' This function returns an RLE / RLEList or data.frame
#' containing coverage data from the given COV file\cr\cr
#' COV files are generated by SpliceWiz's [processBAM] and [BAM2COV] functions.
#' It records alignment coverage for each nucleotide in the given BAM file.
#' It stores this data in "COV" format, which is an indexed BGZF-compressed
#' format specialised for the storage of unstranded and stranded alignment
#' coverage in RNA sequencing.\cr\cr
#' Unlike BigWig files, COV files store coverage for both positive and negative
#' strands.\cr\cr
#' These functions retrieves coverage data from the specified COV file. They
#' are computationally efficient as they utilise random-access to rapidly
#' search for the requested data from the COV file.\cr\cr
#'
#' @param file (Required) The file name of the COV file
#' @param seqname (Required for `getCoverage_DF`) A string denoting the
#'  chromosome name. If left blank in `getCoverage`, retrieves RLEList
#' containing coverage of the entire file.
#' @param start,end 1-based genomic coordinates. If `start = 0` and
#'   `end = 0`, will retrieve RLE of specified chromosome.
#' @param strand Either "*", "+", or "-"
#' @param strandMode The stranded-ness of the RNA-seq experiment. "unstranded"
#'   means that an unstranded protocol was used. Stranded protocols can be
#'   either "forward", where the first read is the same strand as the
#'   expressed transcript, or "reverse" where the second strand is the same
#'   strand as the expressed transcript.
#' @param regions A GRanges object for a set of regions to obtain mean / total
#'   coverage from the given COV file.
#' @param region In `getCoverageBins`, a single query region as a GRanges object
#' @param bins In `getCoverageBins`, the number of bins to divide the given
#'   `region`. If `bin_size` is given, overrides this parameter
#' @param bin_size In `getCoverageBins`, the number of nucleotides per bin
#' @return
#' For `getCoverage`: If seqname is left as "", returns an RLEList of the
#'   whole BAM file, with each RLE in the list containing coverage data for
#'   one chromosome. Otherwise, returns an RLE containing coverage data for
#'   the requested genomic region
#'
#' For `getCoverage_DF`: Returns a two-column data frame, with the first column
#' `coordinate` denoting genomic coordinate, and the second column `value`
#' containing the coverage depth for each coordinate nucleotide.
#'
#' For `getCoverageRegions`: Returns a GRanges object with an extra metacolumn:
#'   `cov_mean`, which gives the mean coverage of each of the given ranges.
#'
#' For `getCoverageBins`: Returns a GRanges object which spans the given
#'   `region`, divided by the number of `bins` or by width as given by
#'   `bin_size`. Mean coverage in each bin is calculated (returned by the
#'   `cov_mean` metadata column). This function is useful for retrieving
#'   coverage of a large region for visualisation, especially when the
#'   size of the region vastly exceeds the width of the figure.
#'
#' @examples
#' se <- SpliceWiz_example_NxtSE()
#'
#' cov_file <- covfile(se)[1]
#'
#' # Retrieve Coverage as RLE
#'
#' cov <- getCoverage(cov_file, seqname = "chrZ",
#'   start = 10000, end = 20000,
#'   strand = "*"
#' )
#'
#' # Retrieve Coverage as data.frame
#'
#' cov.df <- getCoverage_DF(cov_file, seqname = "chrZ",
#'   start = 10000, end = 20000,
#'   strand = "*"
#' )
#'
#' # Retrieve mean coverage of 100-nt window regions as defined
#' # in a GRanges object:
#'
#' gr <- GenomicRanges::GRanges(
#'     seqnames = "chrZ",
#'     ranges = IRanges::IRanges(
#'         start = seq(1, 99901, by = 100),
#'         end = seq(100, 100000, by = 100)
#'     ), strand = "-"
#' )
#'
#' gr.unstranded <- getCoverageRegions(cov_file,
#'     regions = gr,
#'     strandMode = "unstranded"
#' )
#'
#' gr.stranded <- getCoverageRegions(cov_file,
#'     regions = gr,
#'     strandMode = "reverse"
#' )
#'
#' # Retrieve binned coverage of a large region
#'
#' gr.fetch <- getCoverageBins(
#'     cov_file,
#'     region = GenomicRanges::GRanges(seqnames = "chrZ",
#'         ranges = IRanges::IRanges(start = 100, end = 100000),
#'         strand = "*"
#'     ),
#'     bins = 2000
#' )
#'
#' # Plot coverage using ggplot:
#'
#' require(ggplot2)
#'
#' ggplot(cov.df, aes(x = coordinate, y = value)) +
#'     geom_line() + theme_white
#'
#' ggplot(as.data.frame(gr.unstranded),
#'     aes(x = (start + end) / 2, y = cov_mean)) +
#'     geom_line() + theme_white
#'
#' ggplot(as.data.frame(gr.fetch), 
#'     aes(x = (start + end)/2, y = cov_mean)) +
#'     geom_line() + theme_white
#'
#' # Export COV data as BigWig
#'
#' cov_whole <- getCoverage(cov_file)
#' bw_file <- file.path(tempdir(), "sample.bw")
#' rtracklayer::export(cov_whole, bw_file, "bw")
#' @name Coverage
#' @md
NULL

#' @describeIn Coverage Retrieves alignment coverage as an RLE or RLElist
#' @export
getCoverage <- function(file, seqname = "", start = 0, end = 0,
        strand = c("*", "+", "-")) {
    strand <- match.arg(strand)
    if (!(strand %in% c("*", "+", "-"))) {
        .log(paste("In getCoverage(),",
            "Invalid strand. '*', '+' or '-'"))
    }
    strand_int <- ifelse(strand == "*", 2,
        ifelse(strand == "+", 1, 0))

    if (!is.numeric(start) || !is.numeric(end) ||
            (as.numeric(start) > as.numeric(end) & as.numeric(end) > 0)) {
        .log(paste("In getCoverage(),",
            "Zero or negative regions are not allowed"))
    }
    if (seqname == "") {
        raw_list <- c_RLEList_From_Cov(normalizePath(file), strand_int)
        final_list <- list()
        if (length(raw_list) > 0) {
            for (i in seq_len(length(raw_list))) {
                final_list[[i]] <- S4Vectors::Rle(
                    raw_list[[i]]$values, raw_list[[i]]$lengths
                )
            }
        } else {
            return(NULL)
        }
        final_RLE <- as(final_list, "RleList")
        names(final_RLE) <- names(raw_list)
        return(final_RLE)
    } else if (end == 0) {
        raw_RLE <- c_RLE_From_Cov(
            normalizePath(file), as.character(seqname),
            0, 0, strand_int
        )
        final_RLE <- S4Vectors::Rle(raw_RLE$values, raw_RLE$lengths)
    } else {
        raw_RLE <- c_RLE_From_Cov(
            normalizePath(file), as.character(seqname),
            round(as.numeric(start)), round(as.numeric(end)),
            strand_int
        )
        final_RLE <- S4Vectors::Rle(raw_RLE$values, raw_RLE$lengths)
    }
}

.cov_process_regions <- function(file, gr, seq, strand_gr, strand_cov) {
    # adds cov_mean from cov file to gr, only for given seqname seq
    # strand_gr and strand_cov are matching strand info for gr and cov
    if (!any(
        as.character(seqnames(gr)) %in% seq &
        as.character(strand(gr)) %in% strand_gr
    )) {
        return(gr)
    }

    todo <- which(
        as.character(seqnames(gr)) %in% seq &
        as.character(strand(gr)) %in% strand_gr
    )

    cov_data <- getCoverage(
        file, seq,
        min(start(gr[todo])) - 1,
        max(end(gr[todo])),
        strand_cov
    )

    if (is.null(gr$cov_mean)) gr$cov_mean <- 0
    gr$cov_mean[todo] <- round(
        aggregate(
            cov_data, IRanges(start(gr[todo]), end(gr[todo])), FUN = mean
        ), 2
    )

    return(gr)
}

#' @describeIn Coverage Retrieves alignment coverage as a data.frame
#' @export
getCoverage_DF <- function(file, seqname = "", start = 0, end = 0,
        strand = c("*", "+", "-")
) {
    if (seqname == "") .log("seqname must not be omitted in getCoverage_DF")
    cov <- getCoverage(file, seqname, start, end, strand)
    view <- IRanges::Views(cov, start + 1, end)
    view.df <- as.data.frame(view[[1]])
    return(data.frame(
        coordinate = seq(start + 1, end), value = view.df$value
    ))
}

#' @describeIn Coverage Retrieves total and mean coverage of a GRanges object
#' from a COV file
#' @export
getCoverageRegions <- function(file, regions,
        strandMode = c("unstranded", "forward", "reverse")
) {
    strandMode <- match.arg(strandMode)
    if (strandMode == "") strandMode <- "unstranded"

    if (!is(regions, "GRanges")) .log("regions must be a GRanges object")
    if (!isCOV(file)) .log("Given file is not of COV format")
    seqlevels <- c_Cov_Seqnames(normalizePath(file))

    # trim regions by available seqlevels
    if (!any(seqlevels %in% seqlevels(regions)))
        .log("COV file and given regions have incompatible seqnames")

    seqlevels(regions, pruning.mode = "coarse") <- seqlevels
    if (length(regions) == 0) {
        return(regions)
    }

    if (strandMode == "unstranded") {
        for (seq in unique(seqnames(regions))) {
            regions <- .cov_process_regions(file, regions, seq, 
                c("+", "-", "*"), "*")
        }
    } else if (strandMode == "forward") {
        for (seq in unique(seqnames(regions))) {
            regions <- .cov_process_regions(file, regions, seq, "*", "*")
            regions <- .cov_process_regions(file, regions, seq, "+", "+")
            regions <- .cov_process_regions(file, regions, seq, "-", "-")
        }
    } else {
        for (seq in unique(seqnames(regions))) {
            regions <- .cov_process_regions(file, regions, seq, "*", "*")
            regions <- .cov_process_regions(file, regions, seq, "-", "+")
            regions <- .cov_process_regions(file, regions, seq, "+", "-")
        }
    }

    return(regions)
}

#' @describeIn Coverage Retrieves coverage of a single region from a COV file,
#'   binned by the given number of bins or bin_size
#' @export
getCoverageBins <- function(file, region, bins = 2000, 
        strandMode = c("unstranded", "forward", "reverse"),
        bin_size
) {
    strandMode <- match.arg(strandMode)
    if (strandMode == "") strandMode <- "unstranded"

    if (!is(region, "GRanges")) .log("region must be a GRanges object")
    region <- region[1]
    
    if (!isCOV(file)) .log("Given file is not of COV format")
    seqlevels <- c_Cov_Seqnames(normalizePath(file))
    if(!(as.character(seqnames(region)) %in% seqlevels))
        .log("Given region is on a chromosome that is missing in COV file")

    if(!is.numeric(bins) || bins < 1) .log("`bins` must be a numeric value")

    if(missing(bin_size) || !is.numeric(bin_size) ||
            bin_size > width(region) || bin_size < 1) {
        bin_size <- ceiling(width(region) / bins)
    }

    gr.fetch <- .bin_gr(region, bin_size) 

    if (strandMode == "unstranded") {
        strand <- "*"
    } else if (strandMode == "reverse") {
        if(strand(region) == "+") {
            strand <- "-"
        } else if(strand(region == "-")) {
            strand <- "+"
        } else {
            strand <- "*"
        }
    } else {
        strand <- as.character(strand(region))
    }

    df <- as.data.frame(.internal_get_coverage_as_df(
        "sample", file,
        as.character(seqnames(region)), 
        start(region), end(region), strand)
    )
    df <- bin_df(df, bin_size)
    gr.fetch$cov_mean <- df$sample

    return(gr.fetch)
}

.bin_gr <- function(gr, window_size) {
    brks <- seq(1, width(gr) + 1, length.out = (width(gr) + 1) / window_size)
    DT <- data.table(coord = seq(start(gr), end(gr)))
    DT[, c("bin") := findInterval(seq_len(nrow(DT)), brks)]
    DT2 <- DT[, .(start = min(get("coord")), end = max(get("coord"))), 
        by = "bin"]
    DT2[, c("seqnames", "strand") := 
        list(as.character(seqnames(gr)), as.character(strand(gr)))]
    .grDT(DT2)
}

########## Internal functions ##########


# Validate given arguments in plotCoverage()
.plot_cov_validate_args <- function(se, tracks, condition,
        Event, Gene,
        seqname, start, end, bases_flanking,
        ...
) {
    .plot_cov_validate_args_se(se, tracks, condition)
    cov_data <- ref(se)
    checked <- .plot_cov_validate_args_loci(
        cov_data, Event, Gene, seqname, start, end)
    if (!checked) .plot_cov_validate_args_event(se, Event, bases_flanking)
}

# Check se, tracks, conditions
.plot_cov_validate_args_se <- function(se, tracks, condition) {
    if (missing(se) || !is(se, "NxtSE"))
        .log("In plotCoverage, `se` must be a valid `NxtSE` object")

    if (!all(file.exists(covfile(se))))
        .log(paste("In plotCoverage,",
            "COV files are not defined in se.",
            "Please supply the correct paths of the COV files",
            "using covfile(se) <- vector_of_correct_COVfile_paths"))

    # Check condition and tracks
    if (length(tracks) < 1 | length(tracks) > 4)
        .log(paste("In plotCoverage,", "tracks must be of length 1-4"))

    if (!missing(condition)) {
        if (length(condition) != 1)
            .log(paste("In plotCoverage,", "condition must be of length 1"))

        if (!(condition %in% names(colData(se))))
            .log(paste("In plotCoverage,",
                "condition must be a valid column name in colData(se)"))

        condition_options <- unique(colData(se)[, condition])
        if (!all(tracks %in% condition_options))
            .log(paste("In plotCoverage,",
                "some tracks do not match valid condition names in",
                condition))

    } else {
        if (!all(tracks %in% colnames(se)))
            .log(paste("In plotCoverage,",
                "some tracks do not match valid sample names in se"))
    }
}

# Checks Gene and loci. Only this is run if plotGenome is run
.plot_cov_validate_args_loci <- function(cov_data,
    Event, Gene, seqname, start, end, bases_flanking = 0
) {
    if (!all(c("seqInfo", "geneList", "elements", "transcripts") %in%
            names(cov_data)))
        .log(paste("In plotCoverage,",
            "cov_data must be a valid object",
            "created by prepare_covplot_data()"))

    # Check we know where to plot
    if (missing(Event) & missing(Gene) &
            (missing(seqname) | missing(start) | missing(end))
    ) {
        .log(paste("In plotCoverage,",
            "Event or Gene cannot be empty, unless coordinates are provided"))
    } else if ((is_valid(seqname) & is_valid(start) & is_valid(end))) {
        view_chr <- as.character(seqname)
        view_start <- start
        view_end <- end
    } else if (is_valid(Gene)) {
        if (!(Gene %in% cov_data$geneList$gene_id) &
                !(Gene %in% cov_data$geneList$gene_name)) {
            .log(paste("In plotCoverage,",
                Gene, "is not a valid gene symbol or Ensembl gene id"))
        }
        if (!(Gene %in% cov_data$geneList$gene_id)) {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_name") == get("Gene")])
            if (nrow(gene.df) != 1) {
                .log(paste("In plotCoverage,", Gene,
                    "is an ambiguous name referring to 2 or more genes.",
                    "Please provide its gene_id instead"))
            }
        } else {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_id") == get("Gene")])
        }
        view_chr <- as.character(gene.df$seqnames)
        view_start <- gene.df$start
        view_end <- gene.df$end
    } else {
        return(FALSE)
    }
    view_center <- (view_start + view_end) / 2
    view_length <- view_end - view_start
    if (!(view_chr %in% names(cov_data$seqInfo)))
        .log(paste("In plotCoverage,", view_chr,
            "is not a valid chromosome reference name in the given genome"))

    if (is_valid(bases_flanking) &&
            (!is.numeric(bases_flanking) || bases_flanking < 0))
        .log(paste("In plotCoverage,",
            "bases_flanking must be a non-negative number"))

    if (!is.numeric(view_length) || view_length < 0)
        .log(paste("In plotCoverage,",
            "view_length must be a non-negative number"))

    return(TRUE)
}

# Checks whether Event given is valid.
.plot_cov_validate_args_event <- function(se, Event, bases_flanking) {
    cov_data <- ref(se)
    rowData <- as.data.frame(rowData(se))
    if (!(Event %in% rownames(rowData))) {
        .log(paste("In plotCoverage,", Event,
            "is not a valid IR or alternate splicing event in rowData(se)"))
    }
    rowData <- rowData[Event, ]
    view_chr <- tstrsplit(rowData$EventRegion, split = ":")[[1]]
    temp1 <- tstrsplit(rowData$EventRegion, split = "/")
    temp2 <- tstrsplit(temp1[[1]], split = ":")[[2]]
    view_start <- as.numeric(tstrsplit(temp2, split = "-")[[1]])
    view_end <- as.numeric(tstrsplit(temp2, split = "-")[[2]])

    view_center <- (view_start + view_end) / 2
    view_length <- view_end - view_start
    if (!(view_chr %in% names(cov_data$seqInfo)))
        .log(paste("In plotCoverage,", view_chr,
            "is not a valid chromosome reference name in the given genome"))

    if (is_valid(bases_flanking) &&
            (!is.numeric(bases_flanking) || bases_flanking < 0))
        .log(paste("In plotCoverage,",
            "bases_flanking must be a non-negative number"))

    if (!is.numeric(view_length) || view_length < 0)
        .log(paste("In plotCoverage,",
            "view_length must be a non-negative number"))

    return(TRUE)
}

# Work out viewing coordinates based on given request
.plotCoverage_determine_params <- function(
        se, Event, Gene,
        seqname, start, end, zoom_factor, bases_flanking
) {
    cov_data <- ref(se)
    if (!missing(zoom_factor)) {
        tryCatch({
            zoom_factor <- as.numeric(zoom_factor)
        }, error = function(e) {
            zoom_factor <- NULL
        })
    }
    # Prepare zoom window
    if (!missing(seqname) & !missing(start) & !missing(end)) {
        view_chr <- as.character(seqname)
        view_start <- start
        view_end <- end
        if (!is_valid(zoom_factor)) zoom_factor <- 0
    } else if (!missing(Gene)) {
        if (Gene %in% cov_data$geneList$gene_id) {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_id") == get("Gene")])
        } else {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_name") == get("Gene")])
        }
        view_chr <- as.character(gene.df$seqnames)
        view_start <- gene.df$start
        view_end <- gene.df$end
        if (!is_valid(zoom_factor)) zoom_factor <- 0
    } else {
        rowData <- as.data.frame(rowData(se))
        rowData <- rowData[Event, ]
        view_chr <- tstrsplit(rowData$EventRegion, split = ":")[[1]]
        temp1 <- tstrsplit(rowData$EventRegion, split = "/")
        temp2 <- tstrsplit(temp1[[1]], split = ":")[[2]]
        view_start <- as.numeric(tstrsplit(temp2, split = "-")[[1]])
        view_end <- as.numeric(tstrsplit(temp2, split = "-")[[2]])
        if (!is_valid(zoom_factor)) zoom_factor <- 1
    }
    if (zoom_factor < 0) zoom_factor <- 0

    # Apply zoom
    view_center <- (view_start + view_end) / 2
    view_length <- view_end - view_start
    new_view_length <- view_length * 3^zoom_factor + 2 * bases_flanking
    view_start <- round(view_center - new_view_length / 2)
    view_end <- round(view_center + new_view_length / 2)
    # Validate genomic window and shift if invalid
    if (view_start < 1) view_start <- 1
    seqInfo <- cov_data$seqInfo[view_chr]
    seqmax <- GenomeInfoDb::seqlengths(seqInfo)
    if (view_end > seqmax) view_end <- seqmax - 1

    return(list(
        view_chr = view_chr, view_start = view_start, view_end = view_end
    ))
}

.plotGenome_determine_params <- function(
    cov_data, Gene, seqname, start, end, zoom_factor, bases_flanking
) {
    if (!missing(zoom_factor)) {
        tryCatch({
            zoom_factor <- as.numeric(zoom_factor)
        }, error = function(e) {
            zoom_factor <- NULL
        })
    }
    if (!missing(seqname) & !missing(start) & !missing(end)) {
        view_chr <- as.character(seqname)
        view_start <- start
        view_end <- end
        if (!is_valid(zoom_factor)) zoom_factor <- 0
    } else if (!missing(Gene)) {
        if (Gene %in% cov_data$geneList$gene_id) {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_id") == get("Gene")])
        } else {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_name") == get("Gene")])
        }
        view_chr <- as.character(gene.df$seqnames)
        view_start <- gene.df$start
        view_end <- gene.df$end
        if (!is_valid(zoom_factor)) zoom_factor <- 0
    } else {
        .log("Either coordinates or gene name should be given")
    }
    if (zoom_factor < 0) zoom_factor <- 0
    # Apply zoom
    view_center <- (view_start + view_end) / 2
    view_length <- view_end - view_start
    new_view_length <- view_length * 3^zoom_factor + 2 * bases_flanking
    view_start <- round(view_center - new_view_length / 2)
    view_end <- round(view_center + new_view_length / 2)
    # Validate genomic window and shift if invalid
    if (view_start < 1) view_start <- 1
    seqInfo <- cov_data$seqInfo[view_chr]
    seqmax <- GenomeInfoDb::seqlengths(seqInfo)
    if (view_end > seqmax) view_end <- seqmax - 1

    return(list(
        view_chr = view_chr, view_start = view_start, view_end = view_end
    ))
}

# Determines what events to highlight given `norm_event`
.plotCoverage_highlight_events <- function(se, norm_event) {
    if (norm_event == "") return(list())
    
    events_to_highlight <- list()
    rowData <- as.data.frame(rowData(se))
    
    if (rowData$EventType[match(norm_event, rowData$EventName)]
        %in% c("MXE", "SE")) {
        events_to_highlight[[1]] <- c(
            rowData$Event1a[match(norm_event, rowData$EventName)],
            rowData$Event2a[match(norm_event, rowData$EventName)])
    } else {
        events_to_highlight[[1]] <- rowData$Event1a[
            match(norm_event, rowData$EventName)]
    }
    if (rowData$EventType[match(norm_event, rowData$EventName)]
        %in% c("MXE")) {
        events_to_highlight[[2]] <- c(
            rowData$Event1b[match(norm_event, rowData$EventName)],
            rowData$Event2b[match(norm_event, rowData$EventName)])
    } else if (rowData$EventType[match(norm_event, rowData$EventName)]
        %in% c("SE", "A3SS", "A5SS", "ALE", "AFE")) {
        events_to_highlight[[2]] <- rowData$Event1b[
            match(norm_event, rowData$EventName)]
    }
    return(events_to_highlight)
}

# Internal function used to plot everything
.plot_cov_fn <- function(
    view_chr, view_start, view_end, view_strand,
    norm_event, condition, tracks = list(), track_names = NULL, 
    ribbon_mode = "ci",
    se, avail_files,
    transcripts, elems, highlight_events = list(), 
    selected_transcripts = "", reverseGenomeCoords = FALSE,
    plot_key_isoforms = FALSE,
    stack_tracks, graph_mode, conf.int = 0.95,
    t_test = FALSE, condensed = FALSE,
    plotJunctions = FALSE, junctionThreshold = junctionThreshold,
    includeCalculations = FALSE
) {
    args <- as.list(match.call())
    
    # Automatically flips strand if all samples are reversely stranded
    
    args$view_strand_jn <- args$view_strand
    if(args$view_strand != "*") {
        if(all(sampleQC(args$se)$strand == -1)) {
            if(args$view_strand == "+") {
                args$view_strand <- "-"
            } else {
                args$view_strand <- "+"
            }
        }
    }
    
    if (is.null(track_names)) args$track_names <- unlist(tracks)

    data.t_test <- list()

    calcs <- NULL
    if (is_valid(condition) & is_valid(norm_event)) {
        # Calculate normalized values given `condition` and `norm_event`
        calcs <- do.call(.plot_cov_fn_normalize_condition, args)

        if (stack_tracks == TRUE) {
            plot_objs <- .plot_cov_fn_plot_by_condition_stacked(calcs, args)
        } else {
            plot_objs <- .plot_cov_fn_plot_by_condition_unstacked(calcs, args)
        }
        if (t_test) plot_objs <- .plot_cov_fn_ttest(plot_objs, calcs, args)
    } else if (!is_valid(condition)) {
        # Plot individual coverages on separate tracks
        plot_objs <- do.call(.plot_cov_fn_indiv, args)
    }

    # Summarize non-null tracks
    plot_tracks <- plot_objs$pl_track[
        unlist(lapply(plot_objs$pl_track, function(x) !is.null(x)))]

    ##### Plot reference track #####
    
    ## Work out which junctions are actually represented
    juncs <- plot_objs$juncs

    p_ref <- .plot_view_ref_fn(
        view_chr, view_start, view_end,
        transcripts, elems, highlight_events,
        condensed = condensed,
        selected_transcripts = selected_transcripts,
        reverseGenomeCoords = reverseGenomeCoords,
        plot_key_isoforms = plot_key_isoforms,
        filterByJunctions = juncs
    )

    # Remove legend for p_ref; this causes trouble for plotly
    for (i in seq_len(length(p_ref$pl$x$data))) {
        p_ref$pl$x$data[[i]]$showlegend <- FALSE
    }
    # Put the reference track on the final position
    plot_tracks[[length(plot_tracks) + 1]] <- p_ref$pl
    # Put the reference track in position #6 of ggplot list
    plot_objs$gp_track[[6]] <- p_ref$gp +
        theme(legend.position = "none") +
        labs(x = paste("Chromosome", view_chr))
        
    # Combine multiple tracks into a plotly plot
    final_plot <- .plot_cov_fn_finalize(
        plot_tracks, view_start, view_end, graph_mode)
    # Fix legend title for stacked plotly plots:
    
    if (
        is_valid(condition) & is_valid(norm_event) & 
        stack_tracks == TRUE
    ) {
        final_plot <- final_plot %>% 
            layout(legend = list(title=list(text=condition)))    
    } 

    if(includeCalculations) {
        return(list(
            ggplot = plot_objs$gp_track, final_plot = final_plot,
            calcs = calcs
        ))
        
    }
    return(list(
        ggplot = plot_objs$gp_track,
        final_plot = final_plot,
        exonRanges = p_ref$exonRanges
    ))
}

############################### PLOT GENOME TRACK ##############################

# Plots the transcript track, highlighting where required
.plot_view_ref_fn <- function(
    view_chr, view_start, view_end,
    transcripts, elems, highlight_events = list(),
    condensed = FALSE, selected_transcripts = "",
    reverseGenomeCoords = FALSE,
    plot_key_isoforms = FALSE,
    filterByJunctions = NULL
) {
    DTlist <- .plot_view_ref_fn_getDTlist(
        view_chr, view_start, view_end,
        transcripts, elems, highlight_events,
        condensed, selected_transcripts,
        plot_key_isoforms, filterByJunctions
    )
    DTplotlist <- .plot_view_ref_fn_groupDTlist(DTlist,
        view_chr, view_start, view_end, highlight_events,
        reverseGenomeCoords
    )

    return(.plot_view_ref_fn_plotDTlist(
        DTplotlist,
        view_chr, view_start, view_end, highlight_events,
        reverseGenomeCoords
    ))
}

.plot_view_ref_fn_getDTlist <- function(
    view_chr, view_start, view_end,
    transcripts, elems, highlight_events = list(),
    condensed = FALSE, selected_transcripts = "",
    plot_key_isoforms = FALSE,
    filterByJunctions = NULL
) {
    transcripts.DT <- transcripts[
        get("seqnames") == view_chr &
        get("start") <= view_end + (view_end - view_start) &
        get("end") >= view_start - (view_end - view_start)
    ]
    setorderv(transcripts.DT, c("transcript_support_level", "width"))
    if (length(selected_transcripts) > 1 || selected_transcripts != "") {
        transcripts.DT <- transcripts.DT[
            get("transcript_id") %in% selected_transcripts |
            get("transcript_name") %in% selected_transcripts
        ]
    } # filter transcripts if applicable

    reduced.DT <- elems[
        get("transcript_id") %in% transcripts.DT$transcript_id &
        get("type") %in% c("CDS", "exon", "intron")
    ]
    
    # Transfer feature_id from exons -> CDS
    CDS.DT <- reduced.DT[get("type") == "CDS"]
    if(nrow(CDS.DT) > 0) {
        exons.DT <- reduced.DT[get("type") == "exon"]
        introns.DT <- reduced.DT[get("type") == "intron"]

        exons.gr <- .grDT(exons.DT)
        CDS.gr <- .grDT(CDS.DT)
        OL <- findOverlaps(exons.gr, CDS.gr)
        
        OL.DT <- data.table(
            from = OL@from, to = OL@to
        )
        OL.DT[, c("feature_id", "exon_trid", "cds_trid") := list(
            exons.DT$feature_id[get("from")],
            exons.DT$transcript_id[get("from")],
            CDS.DT$transcript_id[get("to")]
        )]
        OL.DT <- OL.DT[get("exon_trid") == get("cds_trid")]
        CDS.DT$feature_id[OL.DT$to] <- OL.DT$feature_id
        
        reduced.DT <- rbind(exons.DT, CDS.DT, introns.DT)
    }

    # Highlight events here
    # highlight_events is of syntax chrX:10000-11000/-

    reduced.DT <- determine_compatible_events(
        reduced.DT, highlight_events, plot_key_isoforms,
        filtered_events = filterByJunctions
    )

    transcripts.DT <- transcripts.DT[
        get("transcript_id") %in% reduced.DT$transcript_id]

    if (condensed != TRUE & nrow(transcripts.DT) <= 100) {
        condense_this <- FALSE
        transcripts.DT[, c("group_id") := get("transcript_id")]
        reduced.DT[, c("group_id") := get("transcript_id")]
    } else {
        condense_this <- TRUE
        transcripts.DT[, c("group_id") := get("gene_id")]
        reduced.DT[transcripts.DT, on = "transcript_id",
            c("group_id") := get("gene_id")]
    }

    return(list(
        transcripts.DT = transcripts.DT,
        reduced.DT = reduced.DT,
        condense_this = condense_this
    ))
}

determine_compatible_events <- function(
        reduced.DT, highlight_events, plot_key_isoforms,
        filtered_events = NULL
) {
    introns <- reduced.DT[get("type") == "intron"]
    introns[, c("highlight") := "0"]
    exons <- reduced.DT[get("type") == "exon"]
    exons[, c("highlight") := "0"]
    misc <- reduced.DT[get("type") == "CDS"]
    misc[, c("highlight") := "0"]

    tr_filter <- c()
    if (length(highlight_events) == 1) {
        # IR / RI only
        gr <- coord2GR(highlight_events[[1]])
        introns.gr <- .grDT(introns)
        OL <- findOverlaps(gr, introns.gr)
        introns[OL@to, c("highlight") := "1"]
        OL2 <- findOverlaps(gr, introns.gr, type = "equal")
        introns[OL2@to, c("highlight") := "2"]
        
        tr_filter <- unique(introns[get("highlight") != "0"]$transcript_id)
    } else if (length(highlight_events) == 2) {
        AS_count <- 1
        for (event in highlight_events) {
            tr <- list()
            for(i in seq_len(length(event))) {
                ev <- event[i]
                OL <- findOverlaps(coord2GR(ev), .grDT(introns), type = "equal")
                tr[[i]] <- introns[OL@to]$transcript_id
            }
            tr_final <- NULL
            if(length(event) == 2) {
                tr_final <- intersect(tr[[1]], tr[[2]])
            } else {
                tr_final <- tr[[1]]
            }
            
            if(length(tr_final) > 0) {
                # Highlight introns that match exact junction
                gr <- coord2GR(event)
                introns.gr <- .grDT(introns)
                OL <- findOverlaps(gr, introns.gr, type = "equal")

                introns[
                    seq_len(nrow(introns)) %in% OL@to & 
                    get("transcript_id") %in% tr_final, 
                    c("highlight") := as.character(AS_count)
                ]

                # Remove novel transcripts if not all introns highlighted
                introns_novel <- introns[
                    grepl("novel", get("transcript_id")) &
                    get("highlight") == as.character(AS_count)
                ]
                introns_novel_noHL <- introns[
                    get("transcript_id") %in% introns_novel$transcript_id &
                    get("highlight") == "0"
                ]
                if(nrow(introns_novel_noHL) > 0) {
                    introns[
                        get("transcript_id") %in% introns_novel_noHL$transcript_id,
                        c("highlight") := "0"
                    ]
                    tr_final <- setdiff(tr_final, 
                        introns_novel_noHL$transcript_id)
                }
                
                coord_keys_start <- end(gr[1]) + 1
                coord_keys_end <- start(gr[1]) - 1
                if (length(gr) == 2) {
                    coord_keys_start <- c(coord_keys_start, end(gr[2]) + 1)
                    coord_keys_end <- c(coord_keys_end, start(gr[2]) - 1)
                }
                exons[get("transcript_id") %in% tr_final &
                    (get("start") %in% coord_keys_start | 
                    get("end") %in% coord_keys_end),
                    c("highlight") := as.character(AS_count)]
            }
 
            tr_filter <- c(tr_filter, tr_final)
            AS_count <- AS_count + 1
        }
        
        # transfer highlighting from exons to CDS
        for(tr in unique(exons[get("highlight") != "0"]$transcript_id)) {
            exons_selected <- exons[get("transcript_id") == tr &
                get("highlight") != "0"]
            highlight_id <- exons_selected$highlight[1]
            OL <- findOverlaps(
                .grDT(misc),
                .grDT(exons_selected)
            )
            misc[seq_len(nrow(misc)) %in% unique(OL@from) & 
                get("transcript_id") == tr,
                c("highlight") := highlight_id]
        }
    }
    
    if(!is.null(filtered_events)) {
        # filter vectors
        novelTrID <- preservePut <- InTrID <- c()
        intronlessID <- exons[
            !(get("transcript_id") %in% introns$transcript_id)
        ]$transcript_id
        
        filterByDT <- as.data.table(coord2GR(filtered_events))
        filterByDT <- filterByDT[, c("seqnames", "start", "end"),
            with = FALSE]

        # Remove novel transcripts if at least 1 junction not represented
        intronsOut <- introns[!filterByDT, on = c("seqnames", "start", "end")]
        if(nrow(intronsOut) > 0) {
            novelTrID <- intronsOut$transcript_id
            novelTrID <- novelTrID[grepl("novel", novelTrID)]
        }
        
        intronsIn <- introns[filterByDT, on = c("seqnames", "start", "end")]
        InTrID <- intronsIn$transcript_id
        InTrID <- InTrID[!(InTrID %in% novelTrID)]

        # Remove all novel putative tandem transcripts unless both introns
        #   in viewing frame
        intronsPut <- intronsIn[grepl("novelPutTrID", get("transcript_id"))]
        if(nrow(intronsPut) > 0) {
            preservePut <- intronsPut$transcript_id[
                duplicated(intronsPut$transcript_id)]
        }

        introns <- introns[
            # Retain if not a novel junction with no in-view junctions expressed
            !(get("transcript_id") %in% novelTrID) & (

                # Retain if important
                (get("transcript_id") %in% tr_filter) |            

                # Retain if annotated and any in-view junctions expressed
                (get("transcript_id") %in% InTrID) |
                
                # Retain if both junctions of TJ-Puts are expressed
                (get("transcript_id") %in% preservePut)
            )
        ]
        exons <- exons[
            get("transcript_id") %in% c(introns$transcript_id, intronlessID)
        ]
        misc <- misc[
            get("transcript_id") %in% c(introns$transcript_id, intronlessID)
        ]
        
    }
    
    if(plot_key_isoforms) {
        introns <- introns[get("transcript_id") %in% tr_filter]
        exons <- exons[get("transcript_id") %in% tr_filter]
        misc <- misc[get("transcript_id") %in% tr_filter]
    } 
    return(rbind(introns, exons, misc))
}

.plot_view_ref_fn_groupDTlist <- function(DTlist,
    view_chr, view_start, view_end, highlight_events = list(),
    reverseGenomeCoords = FALSE
) {
    transcripts.DT <- DTlist$transcripts.DT
    reduced.DT <- DTlist$reduced.DT
    condense_this <- DTlist$condense_this
    
    exonRanges <- .plot_view_ref_fn_getExonRanges(
        reduced.DT, transcripts.DT,
        view_start, view_end
    )
    
    group.grl <- split(.grDT(transcripts.DT), transcripts.DT$group_id)
    group.DT <- as.data.table(range(group.grl))
    group.DT$group <- NULL
    data.table::setnames(group.DT, "group_name", "group_id")
    # apply plot_order on transcripts.DT
    OL <- findOverlaps(.grDT(group.DT), .grDT(group.DT), ignore.strand = TRUE)
    group.DT$plot_level <- 1
    cur_level <- 1
    while (any(group.DT$plot_level == cur_level)) {
        j <- match(cur_level, group.DT$plot_level)
        repeat {
            bump_up_trs <- unique(OL@to[OL@from == j])
            bump_up_trs <- bump_up_trs[bump_up_trs > j]
            bump_up_trs <- bump_up_trs[
                group.DT$plot_level[bump_up_trs] == cur_level]
            if (length(bump_up_trs) > 0)
                group.DT[bump_up_trs, c("plot_level") := cur_level + 1]

            j <- j + match(cur_level, group.DT$plot_level[-seq_len(j)])
            if (is.na(j)) break
        }
        cur_level <- cur_level + 1
    }

    if (condense_this == TRUE) {
        group.DT[transcripts.DT, on = "group_id",
            c("group_name", "group_biotype") :=
            list(get("i.gene_name"), get("i.gene_biotype"))]
    } else {
        group.DT[transcripts.DT, on = "group_id",
            c("group_name", "group_biotype") :=
            list(get("i.transcript_name"), get("i.transcript_biotype"))]
    }

    group.DT <- group.DT[get("end") > view_start & get("start") < view_end]

    group.DT[get("strand") == "+", c("display_name") :=
        paste(get("group_name"), "(+)", get("group_biotype"))]
    group.DT[get("strand") == "-", c("display_name") :=
        paste(get("group_name"), "(-)", get("group_biotype"))]    

    if(reverseGenomeCoords) {
        group.DT[get("strand") == "-", c("display_name") :=
            paste(get("display_name"), "->>")]
        group.DT[get("strand") == "+", c("display_name") :=
            paste("<--", get("display_name"))]
    
    } else {
        group.DT[get("strand") == "+", c("display_name") :=
            paste(get("display_name"), "->>")]
        group.DT[get("strand") == "-", c("display_name") :=
            paste("<--", get("display_name"))]  
    }
    group.DT[, c("disp_x") := 0.5 * (get("start") + get("end"))]
    group.DT[get("start") < view_start & get("end") > view_start,
        c("disp_x") := 0.5 * (view_start + get("end"))]
    group.DT[get("end") > view_end & get("start") < view_end,
        c("disp_x") := 0.5 * (get("start") + view_end)]
    group.DT[get("start") < view_start & get("end") > view_end,
        c("disp_x") := 0.5 * (view_start + view_end)]

    reduced.DT$group_id <- factor(reduced.DT$group_id,
        unique(group.DT$group_id), ordered = TRUE)
    reduced.DT[group.DT, on = "group_id",
        c("plot_level") := get("i.plot_level")]

    setorderv(reduced.DT, "highlight")

    return(list(
        group.DT = group.DT,
        reduced.DT = reduced.DT,
        condense_this = condense_this,
        exonRanges = exonRanges
    ))
}

.plot_view_ref_fn_getExonRanges <- function(
        reduced.DT, transcripts.DT,
        view_start, view_end
) {
    if(exonsMode == "off") return(NULL)
    
    Tr_DT <- copy(transcripts.DT[!grepl("intron", get("transcript_biotype"))])
    trids <- Tr_DT$transcript_id
    DT <- copy(reduced.DT)
    DT <- DT[get("type") == "exon"]
    DT <- DT[get("transcript_id") %in% trids]
    
    if(exonsMode == "keyExonsOnly") {
        DT <- DT[get("highlight") != "0"]
        if(nrow(DT) == 0) {
            .log("No highlighted exons, reverting to exonsMode == 'exonsOnly'",
                "warning")
            DT <- copy(reduced.DT)
        }
    }
    
    if(nrow(DT) == 0) {
        .log("No exons in range, reverting to exonsMode = 'off'", "warning")
        return(NULL)
    }

    gr <- .grDT(DT)
    exons_gr <- reduce(gr, ignore.strand=TRUE)
    
    # Expand exon windows so there is some space
    BiocGenerics::start(exons_gr) <- BiocGenerics::start(exons_gr) - 100
    BiocGenerics::end(exons_gr) <- BiocGenerics::end(exons_gr) + 100
    
    # Reduce overlapping ranges
    if(length(exons_gr) > 1) {
        for(i in seq_len(length(exons_gr) - 1)) {
            if(
                BiocGenerics::end(exons_gr[i]) >
                BiocGenerics::start(exons_gr[i+1])
            ) {
                midpt <- 0.5 * (
                    BiocGenerics::start(exons_gr[i+1]) +
                    BiocGenerics::end(exons_gr[i])
                )
                BiocGenerics::end(exons_gr[i]) <- max(
                    midpt - 10, BiocGenerics::start(exons_gr[i]) + 1
                )
                BiocGenerics::start(exons_gr[i+1]) <- min(
                    midpt + 10, BiocGenerics::end(exons_gr[i+1]) - 1
                )
            }
        }
    }
    return(exons_gr)
}

.plot_view_ref_fn_plotDTlist <- function(
    DTplotlist,
    view_chr, view_start, view_end, highlight_events,
    reverseGenomeCoords = FALSE
) {
    group.DT <- DTplotlist$group.DT
    reduced <- DTplotlist$reduced.DT
    reduced <- reduced[!is.na(reduced$plot_level)]
    condense_this <- DTplotlist$condense_this
    exonRanges <- DTplotlist$exonRanges

    # Hover Text annotation
    reduced[, c("Information") := ""]
    reduced[get("type") %in% c("exon", "CDS"), c("Information") := paste(
        paste(get("transcript_id"), "exon", get("aux_id")),
        paste0("(", get("feature_id"), ")"),
        paste0(get("seqnames"), ":", get("start"), "-", get("end"), "/", 
            get("strand")),
        sep = "\n"
    )]
    reduced[get("type") == "intron", c("Information") := paste(
        get("feature_id"), 
        paste0(get("seqnames"), ":", get("start"), "-", get("end"), "/", 
            get("strand")),
        sep = "\n"
    )]
    
    reduced <- as.data.frame(reduced)
    # p <- ggplot(reduced)
    p <- suppressWarnings(ggplot(reduced, aes(text = get("Information"))))
    
    if (nrow(subset(reduced, type = "intron")) > 0) {
        # p <- p + geom_segment(data = reduced[reduced$type == "intron", ],
            # aes(x = get("start"), xend = get("end"),
                # y = get("plot_level"), yend = get("plot_level"),
            # color = get("highlight")))
        reducedIntrons <- reduced[reduced$type == "intron", ]
        reducedIntronsExpanded <- c()
        for(i in seq_len(nrow(reducedIntrons))) {
            reducedIntronsExpanded <- rbind(reducedIntronsExpanded, data.frame(
                start = seq(reducedIntrons$start[i], reducedIntrons$end[i],
                    length.out = 10),
                end = seq(reducedIntrons$start[i], reducedIntrons$end[i],
                    length.out = 10),
                plot_level = reducedIntrons$plot_level[i],
                highlight = reducedIntrons$highlight[i],
                Information = reducedIntrons$Information[i]              
            ))
        }
        p <- p + geom_line(data = reducedIntronsExpanded,
            aes(x = get("start"), y = get("plot_level"),
            color = get("highlight"), group = get("Information")))
    }
    if (nrow(reduced[reduced$type != "intron", ]) > 0) {
        p <- p + geom_rect(data = reduced[reduced$type != "intron", ],
            aes(xmin = get("start"), xmax = get("end"),
                ymin = get("plot_level") - 0.1 -
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                ymax = get("plot_level") + 0.1 +
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                fill = get("highlight")
            )
        )
    }
    if (length(highlight_events) > 0) {
        p <- p + scale_color_manual(values = c("black", "blue", "red")) +
            scale_fill_manual(values = c("black", "blue", "red"))
    }
    p <- p + theme_white_legend_plot_track +
        theme(axis.text.y = element_blank(), axis.title.y = element_blank(),
            legend.title = element_blank())
    if (condense_this == TRUE) {
        anno <- list(
            x = group.DT$disp_x,
            y = group.DT$plot_level - 0.5 + 0.3 * runif(rep(1, nrow(group.DT))),
            text = group.DT$display_name,
            xref = "x", yref = "y", showarrow = FALSE)
    } else {
        anno <- list(
            x = group.DT$disp_x,
            y = group.DT$plot_level - 0.4,
            text = group.DT$display_name,
            xref = "x", yref = "y", showarrow = FALSE)
    }

    if (nrow(group.DT) == 0) {
        max_plot_level <- 1
    } else {
        max_plot_level <- max(group.DT$plot_level)
    }

    gp <- p + geom_text(data = data.frame(x = anno[["x"]], y = anno[["y"]],
            Information = anno[["text"]]),
        aes(x = get("x"), y = get("y"), label = get("Information")))

    if(reverseGenomeCoords) {
        gp <- gp + coord_cartesian(
            xlim = c(view_end, view_start),
            ylim = c(
                min(reduced$plot_level) - 1,
                max(reduced$plot_level) + 0.5
            ),
            expand = FALSE
        )   
    } else {
        gp <- gp + coord_cartesian(
            xlim = c(view_start, view_end),
            ylim = c(
                min(reduced$plot_level) - 1,
                max(reduced$plot_level) + 0.5
            ),
            expand = FALSE
        )    
    }
        
    pl <- ggplotly(p, tooltip = "text") %>%
    layout(
        annotations = anno, dragmode = "pan",
        xaxis = list(range = c(view_start, view_end),
            title = paste("Chromosome/Scaffold", view_chr)),
        yaxis = list(range = c(0, 1 + max_plot_level),
            fixedrange = TRUE)
    )
    return(list(gp = gp, pl = pl, exonRanges = exonRanges))
}

################################# PLOT TRACKS ##################################

# Calculations to normalise samples by condition
.plot_cov_fn_normalize_condition <- function(
    view_chr, view_start, view_end, view_strand,
    norm_event, condition, tracks = list(), track_names = "", se, avail_files,
    conf.int = 0.95, t_test = FALSE, ...
) {
    cur_zoom <- floor(log((view_end - view_start) / 50) / log(3))
    depth_min <- 10 # depth required for sample to be included in averages

    data.list <- list()
    junc.list <- list()
    data.t_test <- fac <- NULL
    max_tracks <- 0
    samples_plotted <- c()
    junc_PSI <- .plot_cov_fn_retrieve_PSI(view_chr, view_start, view_end, 
        se = se, ...)
    for (i in seq_len(4)) {
        if (length(tracks) >= i && is_valid(tracks[[i]])) {
            track_samples <- tracks[[i]]
            colData <- colData(se)
            samples <- rownames(colData)[
                unlist(as.character(colData[, condition])
                    == track_samples)]
            event_norms <- assay(se, "Depth")[norm_event, samples]
            samples <- samples[event_norms >= depth_min]
            event_norms <- event_norms[event_norms >= depth_min]
            junc_PSI_track <- NA
            
            if (length(avail_files[samples]) > 0 &&
                    all(file.exists(avail_files[samples]))) {
                samples_plotted <- c(samples_plotted, samples)
                
                if(is(junc_PSI, "data.frame")) 
                    junc_PSI_track <- junc_PSI[, samples]

                df <- as.data.frame(.internal_get_coverage_as_df(
                    samples, avail_files[samples],
                    view_chr, view_start, view_end, view_strand))
                # bin anything with cur_zoom > 4
                df <- bin_df(df, max(1, 3^(cur_zoom - 4)))
                # message(paste("Group getCoverage performed for", condition))
                for (todo in seq_len(length(samples))) {
                    df[, samples[todo]] <-
                        df[, samples[todo]] / event_norms[todo]
                }
                if (t_test == TRUE) {
                    if (is.null(data.t_test)) {
                        data.t_test <- as.matrix(df)
                        fac <- rep(as.character(i), ncol(df) - 1)
                    } else {
                        data.t_test <- cbind(
                            data.t_test, as.matrix(df[, -1]))
                        fac <- c(fac, rep(as.character(i), ncol(df) - 1))
                    }
                }

                df$mean <- rowMeans(as.matrix(df[, samples]))
                df$sd <- rowSds(as.matrix(df[, samples]))
                n <- length(samples)
                df$sem <- df$sd / sqrt(n)
                df$ci <- qt((1 + conf.int) / 2, df = n - 1) * df$sd / sqrt(n)

                if (length(track_names) == length(tracks)) {
                    df$track <- track_names[i]
                } else {
                    df$track <- as.character(i)
                }
                DT <- as.data.table(df)
                DT <- DT[, c("x", "mean", "sd", "sem", "ci", "track")]
                data.list[[i]] <- DT
                junc.list[[i]] <- junc_PSI_track
                max_tracks <- max_tracks + 1
            }
        }
    }
    return(list(
        data.list = data.list, data.t_test = data.t_test,
        fac = fac, max_tracks = max_tracks,
        junc.list = junc.list,
        samples = samples_plotted
    ))
}

# Plot all conditions into one track
.plot_cov_fn_plot_by_condition_stacked <- function(calcs, args) {
    max_tracks <- calcs$max_tracks
    gp_track <- pl_track <- list()
    juncs_plotted <- c()
    for (i in seq_len(4)) {
        if (length(calcs$data.list) >= i && !is.null(calcs$data.list[[i]])) {
            df <- as.data.frame(calcs$data.list[[i]])
            dfJn <- .plot_cov_fn_PSI_make_jn_arcs(df, calcs$junc.list[[i]],
                0.1 * max(df$mean), args$junctionThreshold)
            juncs_plotted <- c(juncs_plotted, unique(dfJn$coord))
        }
    }
    
    df <- as.data.frame(rbindlist(calcs$data.list))
    if (nrow(df) > 0) {
        if (length(args$track_names) == length(args$tracks))
            df$track <- factor(df$track, args$track_names)
        df$info <- paste(
            paste0("Track: ", df$track), 
            paste0("Coordinate: ", df$x), 
            paste0("Norm-Depth (mean): ", round(df$mean, 4)),
            paste0("Norm-Depth (", args$ribbon_mode, "): ", 
                round(unlist(df[, args$ribbon_mode]), 4)),
            sep = "\n"
        )
        
        suppressWarnings({
            gp_track[[1]] <- ggplot(df, aes_string(text = "info")) +
                geom_hline(yintercept = 0)            
        })
        if(args$ribbon_mode %in% c("ci", "sd", "sem")) {
            gp_track[[1]] <- gp_track[[1]] +
            geom_ribbon(data = df, alpha = 0.2,
                aes(x = get("x"), y = get("mean"),
                ymin = get("mean") - get(args$ribbon_mode),
                ymax = get("mean") + get(args$ribbon_mode),
                fill = get("track"),
                group = get("track")))
        }

        gp_track[[1]] <- gp_track[[1]] +
            geom_line(data = df, aes(x = get("x"),
                y = get("mean"), colour = get("track"),
                group = get("track")
            )) +
            labs(y = "Normalized Coverage") +
            theme_white_legend +
            theme(legend.title = element_blank()) # +
            yrange <- c(0, 1.05 * 
                layer_scales(gp_track[[1]])$y$range$range[2]
            )
        pl_track[[1]] <- ggplotly(gp_track[[1]],
            tooltip = c("x", "y", "ymin", "ymax")
        )
        pl_track[[1]] <- pl_track[[1]] %>% layout(
            dragmode = "zoom",
            yaxis = list(range = yrange,
                rangemode = "tozero", fixedrange = TRUE)
        )
        for (j in seq_len(max_tracks)) {
            pl_track[[1]]$x$data[[1 + j]]$showlegend <- FALSE
            pl_track[[1]]$x$data[[1 + j + max_tracks]]$showlegend <- TRUE
            if (length(args$track_names) >= max_tracks) {
                pl_track[[1]]$x$data[[1 + j]]$name <- args$track_names[j]
                pl_track[[1]]$x$data[[1 + j + max_tracks]]$name <-
                    args$track_names[j]
            } else {
                pl_track[[1]]$x$data[[1 + j]]$name <-
                    paste(args$condition, args$tracks[[j]])
                pl_track[[1]]$x$data[[1 + j + max_tracks]]$name <-
                    paste(args$condition, args$tracks[[j]])
            }
        }

        # remove x axis label, rename y axis
        gp_track[[1]] <- gp_track[[1]] + theme(axis.title.x = element_blank()) +
            labs(x = "", y = "Normalized Coverage")
        
        if(args$reverseGenomeCoords) {
            gp_track[[1]] <- gp_track[[1]] + 
                coord_cartesian(                    
                    xlim = c(args$view_end, args$view_start),
                    ylim = yrange,
                    expand = FALSE
                )
        } else {
            gp_track[[1]] <- gp_track[[1]] + 
                coord_cartesian(                    
                    xlim = c(args$view_start, args$view_end),
                    ylim = yrange,
                    expand = FALSE
                )
        }

    }
    return(list(
        gp_track = gp_track, pl_track = pl_track, juncs = unique(juncs_plotted)
    ))
}

# Plot each condition into separate track
.plot_cov_fn_plot_by_condition_unstacked <- function(calcs, args) {
    max_tracks <- calcs$max_tracks
    gp_track <- pl_track <- list()
    juncs_plotted <- c()
    for (i in seq_len(4)) {
        if (length(calcs$data.list) >= i && !is.null(calcs$data.list[[i]])) {
            df <- as.data.frame(calcs$data.list[[i]])
            df$info <- paste(
                paste0("Coordinate: ", df$x), 
                paste0("Norm-Depth (mean): ", round(df$mean, 4)),
                paste0("Norm-Depth (", args$ribbon_mode, "): ", 
                    round(unlist(df[, args$ribbon_mode]), 4)),
                sep = "\n"
            )
            df$track <- paste(args$condition, args$tracks[[i]])
            dfJn <- .plot_cov_fn_PSI_make_jn_arcs(df, calcs$junc.list[[i]],
                0.1 * max(df$mean), args$junctionThreshold)
            juncs_plotted <- c(juncs_plotted, unique(dfJn$coord))
            if(args$plotJunctions) {
                dtJn <- as.data.table(dfJn)
                dtJn[, c("xlabel", "ylabel") := list(
                    mean(get("x")), mean(get("y"))), 
                    by = c("info", "value")
                ]
                dtJn <- unique(dtJn[, 
                    c("info", "value", "xlabel", "ylabel"), with = FALSE])
                dfJnSum <- as.data.frame(dtJn)                
            } else {
                dfJnSum <- NA
            }
            
            suppressWarnings({
                gp_track[[i]] <- ggplot(df, aes(text = get("info"))) +
                    geom_hline(yintercept = 0)            
            })
            if(args$ribbon_mode %in% c("ci", "sd", "sem")) {
                gp_track[[i]] <- gp_track[[i]] +
                geom_ribbon(data = df, alpha = 0.2,
                    aes(
                        x = get("x"), y = get("mean"),
                        ymin = get("mean") - get(args$ribbon_mode),
                        ymax = get("mean") + get(args$ribbon_mode),
                        group = get("track")
                    )
                )
            }
            gp_track[[i]] <- gp_track[[i]] +
                geom_line(data = df,
                    aes(
                        x = get("x"), y = get("mean"),
                        group = get("track")
                    )
                ) +
                labs(y = paste(args$condition, args$tracks[[i]])) +
                theme_white_legend
            if(args$plotJunctions) {
                gp_track[[i]] <- gp_track[[i]] +
                    geom_line(data = dfJn, 
                        aes_string(
                            x = "x", y = "yarc",
                            group = "info"
                        ), color = "darkred"
                    ) +
                    geom_text(data = dfJnSum, 
                        aes_string(x = "xlabel", y = "ylabel",
                            label = "value"))
                    yrange <- c(0, 1.05 * max(
                        c(layer_scales(gp_track[[i]])$y$range$range[2],
                        dfJn$yarc)
                    ))
            } else {
                yrange <- c(0, 1.05 * 
                    layer_scales(gp_track[[i]])$y$range$range[2]
                )
            }
            pl_track[[i]] <- ggplotly(gp_track[[i]],
                tooltip = "text"
            )
            pl_track[[i]] <- pl_track[[i]] %>% layout(
                yaxis = list(range = yrange,
                    rangemode = "tozero", fixedrange = TRUE)
            )
            pl_track[[i]]$x$data[[2]]$showlegend <- FALSE
            pl_track[[i]]$x$data[[3]]$showlegend <- FALSE
            if (length(args$track_names) >= i) {
                track_name <- args$track_names[i]
            } else {
                track_name <- paste(args$condition, args$tracks[[i]])
            }
            pl_track[[i]]$x$data[[2]]$name <- track_name
            pl_track[[i]]$x$data[[3]]$name <- track_name
            gp_track[[i]] <- gp_track[[i]] +
                theme(axis.title.x = element_blank()) +
                labs(x = "", y = track_name)

            if(args$reverseGenomeCoords) {
                gp_track[[i]] <- gp_track[[i]] + 
                    coord_cartesian(                    
                        xlim = c(args$view_end, args$view_start),
                        ylim = yrange,
                        expand = FALSE
                    )
            } else {
                gp_track[[i]] <- gp_track[[i]] + 
                    coord_cartesian(                    
                        xlim = c(args$view_start, args$view_end),
                        ylim = yrange,
                        expand = FALSE
                    )
            }
        }
    }
    return(list(
        gp_track = gp_track, pl_track = pl_track, juncs = unique(juncs_plotted)
    ))
}

# Plot t-test track
.plot_cov_fn_ttest <- function(
    plot_objs, calcs, args
) {
    # Plot t-test track
    fac <- NULL
    if ("fac" %in% names(calcs)) fac <- calcs$fac
    if (!is.null(fac) && length(unique(fac)) == 2) {
        fac <- factor(fac)
        t_test <- genefilter::rowttests(
            as.matrix(calcs$data.t_test[, -1]), fac)

        DT <- data.table(x = calcs$data.t_test[, 1])
        DT[, c("t_stat") := -log10(t_test$p.value)]
        plot_objs$gp_track[[5]] <- ggplot() +
            geom_hline(yintercept = 0) +
            geom_line(data = as.data.frame(DT),
                mapping = aes(x = get("x"), y = get("t_stat"))) +
                theme_white_legend
        plot_objs$pl_track[[5]] <- ggplotly(plot_objs$gp_track[[5]],
            tooltip = c("x", "y")
        )
        plot_objs$pl_track[[5]] <- plot_objs$pl_track[[5]] %>% layout(
            yaxis = list(
                rangemode = "tozero",
                title = paste("T-test -log10(p)")
            )
        )
        plot_objs$pl_track[[5]]$x$data[[2]]$showlegend <- FALSE
        plot_objs$gp_track[[5]] <- plot_objs$gp_track[[5]] +
            theme(axis.title.x = element_blank()) +
            labs(y = "log10 t-test") +
            coord_cartesian(                    
                xlim = c(args$view_start, args$view_end),
                expand = FALSE
            )
    }
    return(plot_objs)
}

# Plot individual samples one in each track
.plot_cov_fn_indiv <- function(
    view_chr, view_start, view_end, view_strand,
    tracks = list(), track_names = NULL, avail_files, 
    reverseGenomeCoords,
    plotJunctions, junctionThreshold, ...
) {
    cur_zoom <- floor(log((view_end - view_start) / 50) / log(3))
    gp_track <- pl_track <- list()
    data.list <- list()
    junc_df <- .plot_cov_fn_indiv_retrieve_jn(
        view_chr, view_start, view_end,
        unlist(tracks), ...
    )
    juncs_plotted <- c()
    for (i in seq_len(4)) {
        if (length(tracks) >= i && is_valid(tracks[[i]])) {
            track_samples <- tracks[[i]]
            filename <- avail_files[which(
                names(avail_files) == track_samples)]
            if (length(filename) == 1 && file.exists(filename)) {
                df <- .internal_get_coverage_as_df("sample", filename,
                    view_chr, view_start, view_end, view_strand)
                df <- bin_df(df, max(1, 3^(cur_zoom - 4)))
                dfJn <- .plot_cov_fn_indiv_make_jn_arcs(df, junc_df, 
                    track_samples, 0.1 * max(df$sample), junctionThreshold)
                juncs_plotted <- c(juncs_plotted, unique(dfJn$coord))
                if(plotJunctions) {
                    dtJn <- as.data.table(dfJn)
                    dtJn[, c("xlabel", "ylabel") := list(
                        mean(get("x")), mean(get("y"))), 
                        by = "info"
                    ]
                    dtJn <- unique(dtJn[, 
                        c("info", "value", "xlabel", "ylabel"), with = FALSE])
                    dfJnSum <- as.data.frame(dtJn)                
                } else {
                    dfJnSum <- NA
                }
                data.list[[i]] <- as.data.table(df)
                if ("sample" %in% colnames(df)) {
                    df$info <- paste(
                        paste0("Coordinate: ", df$x), 
                        paste0("Depth: ", df$sample),
                        sep = "\n"
                    )
                    df$group <- track_samples
                    suppressWarnings({
                        gp_track[[i]] <- ggplot(df, aes_string(text = "info"))
                    })
                    gp_track[[i]] <- gp_track[[i]] +
                        geom_hline(yintercept = 0) +
                        geom_line(aes_string(
                            x = "x", y = "sample", group = "group"
                        )) +
                        theme_white_legend
                    if(plotJunctions) {
                        gp_track[[i]] <- gp_track[[i]] +
                            geom_line(data = dfJn, 
                                aes_string(x = "x", y = "yarc",
                                    group = "info"), 
                                    color = "darkred") +
                            geom_text(data = dfJnSum, 
                                aes_string(x = "xlabel", y = "ylabel",
                                    label = "value")) # +
                        yrange <- c(0, 1.05 * max(c(
                            layer_scales(gp_track[[i]])$y$range$range[2],
                            dfJn$yarc
                        )))
                    } else {
                        yrange <- c(0, 
                            1.05 * layer_scales(gp_track[[i]])$y$range$range[2])
                    }
                    pl_track[[i]] <- ggplotly(gp_track[[i]], tooltip = "text")
                    
                    pl_track[[i]] <- pl_track[[i]] %>% layout(
                        yaxis = list(
                            range = yrange,
                            fixedrange = TRUE,
                            title = paste(track_samples, "")
                        )
                    )
                    pl_track[[i]]$x$data[[2]]$showlegend <- FALSE
                    if (!missing(track_names) && length(track_names) >= i) {
                        track_name <- track_names[i]
                    } else {
                        track_name <- track_samples
                    }
                    pl_track[[i]]$x$data[[2]]$name <- track_name
                    gp_track[[i]] <- gp_track[[i]] +
                        theme(axis.title.x = element_blank()) +
                        labs(x = "", y = track_name)
                    
                    if(reverseGenomeCoords) {
                        gp_track[[i]] <- gp_track[[i]] +
                            coord_cartesian(                    
                                xlim = c(view_end, view_start),
                                ylim = yrange,
                                expand = FALSE
                            )
                    } else {
                        gp_track[[i]] <- gp_track[[i]] +
                            coord_cartesian(                    
                                xlim = c(view_start, view_end),
                                ylim = yrange,
                                expand = FALSE
                            )
                    }
                }
            }
        }
    }
    return(list(
        gp_track = gp_track, pl_track = pl_track, juncs = unique(juncs_plotted)
    ))
}

.plot_cov_fn_indiv_retrieve_jn <- function(
        view_chr, view_start, view_end,
        samples_to_get,
        view_strand_jn,
        se = NULL,
        plotJunctions = FALSE, ...
) {
    # if(plotJunctions) {
        gr_select <- GRanges(view_chr, 
            IRanges(view_start, view_end), view_strand_jn)
        OL <- findOverlaps(junc_gr(se), gr_select)

        # Unstrand junction counts summation
        if(view_strand_jn == "*") {
            junc_counts_select  <- as.matrix(junc_counts_uns(se)[
                unique(from(OL)),samples_to_get])
        } else {
            junc_counts_select  <- as.matrix(junc_counts(se)[
                unique(from(OL)),samples_to_get])
        }
        if(nrow(junc_counts_select) == 0) return(NA)

        # junc_counts_select$rownames <- rownames(junc_counts_select)
        # junc_counts_select <- as.data.table(junc_counts_select)        
        
        # final <- as.data.frame(junc_counts_select[, samples_to_get, 
            # with = FALSE])
        # rownames(final) <- junc_counts_select$rownames
        return(as.data.frame(junc_counts_select))
    # } else {
        # return(NA)
    # }
}

.plot_cov_fn_retrieve_PSI <- function(
        view_chr, view_start, view_end,
        view_strand_jn,
        se = NULL,
        plotJunctions = FALSE,
        ...
) {
    # if(plotJunctions) {
        gr_select <- GRanges(view_chr, 
            IRanges(view_start, view_end), view_strand_jn)
        OL <- findOverlaps(junc_gr(se), gr_select)
        
        if(length(unique(from(OL))) == 0) return(NA)
        final  <- as.matrix(junc_PSI(se)[unique(from(OL)),])
        return(as.data.frame(final))
    # } else {
        # return(NA)
    # }
}

.plot_cov_fn_indiv_make_jn_arcs <- function(
        df, junc_df, sample,
        arcHeight = 0,
        junctionThreshold = 0.01
) {
    if(!is(junc_df, "data.frame")) return(NA)
    junc_df_indiv <- junc_df[, sample, drop = FALSE]
    colnames(junc_df_indiv) <- "juncVal"
    
    gr <- coord2GR(rownames(junc_df_indiv))
    junc_df_indiv$juncStart <- start(gr)
    junc_df_indiv$juncEnd <- end(gr)
    
    df$lead <- data.table::shift(df$sample, type = "lead")
    df$lag <- data.table::shift(df$sample, type = "lag")
    df$max <- rowMaxs(as.matrix(df[, c("sample", "lead", "lag")]),
        na.rm = TRUE)
    df$max[is.na(df$max)] <- 0
    
    maxY <- max(df$sample)
    final <- c()
    for(i in seq_len(nrow(junc_df_indiv))) {
        if(junc_df_indiv$juncVal[i] > junctionThreshold * maxY) {
            leftY <- df$max[
                which.min(abs(df$x - junc_df_indiv$juncStart[i]))]
            rightY <- df$max[
                which.min(abs(df$x - junc_df_indiv$juncEnd[i]))]
            outdf <- data.frame(
                x = seq(junc_df_indiv$juncStart[i], junc_df_indiv$juncEnd[i],
                    length.out = 90),
                y = seq(leftY, rightY, length.out = 90)
            )
            outdf$yarc <- outdf$y + sinpi(seq(0,1,length.out = 90)) * arcHeight
            outdf$info <- paste(
                paste0("Junction: ", rownames(junc_df_indiv)[i]),
                paste0("Depth: ", junc_df_indiv$juncVal[i]),
                sep = "\n"
            )
            outdf$coord <- rownames(junc_df_indiv)[i]
            outdf$value <- junc_df_indiv$juncVal[i]
            final <- rbind(final, outdf)
        }
    }
    return(final)
}

.plot_cov_fn_PSI_make_jn_arcs <- function(
        df, junc_df,
        arcHeight = 0,
        junctionThreshold = 0.01
) {
    if(!is(junc_df, "data.frame")) return(NA)
    junc_df_PSI <- data.frame(
        PSImean = rowMeans(as.matrix(junc_df)),
        PSIsd = rowSds(as.matrix(junc_df))
    )
    rownames(junc_df_PSI) <- rownames(junc_df)
    
    gr <- coord2GR(rownames(junc_df_PSI))
    junc_df_PSI$juncStart <- start(gr)
    junc_df_PSI$juncEnd <- end(gr)
    
    df$lead <- data.table::shift(df$mean, type = "lead")
    df$lag <- data.table::shift(df$mean, type = "lag")
    df$max <- rowMaxs(as.matrix(df[, c("mean", "lead", "lag")]),
        na.rm = TRUE)
    df$max[is.na(df$max)] <- 0

    final <- c()
    for(i in seq_len(nrow(junc_df_PSI))) {
        if(junc_df_PSI$PSImean[i] > junctionThreshold) {
            leftY <- df$max[
                which.min(abs(df$x - junc_df_PSI$juncStart[i]))]
            rightY <- df$max[
                which.min(abs(df$x - junc_df_PSI$juncEnd[i]))]
            outdf <- data.frame(
                x = seq(junc_df_PSI$juncStart[i], junc_df_PSI$juncEnd[i],
                    length.out = 90),
                y = seq(leftY, rightY, length.out = 90)
            )
            outdf$yarc <- outdf$y + sinpi(seq(0,1,length.out = 90)) * arcHeight
            outdf$value <- paste0(round(100 * junc_df_PSI$PSImean[i], 1), "+/-", 
                round(100 * junc_df_PSI$PSIsd[i], 1), " %")
            outdf$info <- paste(
                paste0("Junction: ", rownames(junc_df_PSI)[i]),
                paste0("PSI: ", outdf$value),
                sep = "\n"
            )
            outdf$coord <- rownames(junc_df_PSI)[i]
            final <- rbind(final, outdf)
        }
    }
    return(final)
}

# Combine multiple tracks into a plotly plot
.plot_cov_fn_finalize <- function(
    plot_tracks, view_start, view_end, graph_mode
) {
    # Work out which x axis ticks to use, based on zoom level
    view_range <- view_end - view_start
    min_tick_size <- view_range / 15
    tick_order_magn <- 10^floor(log10(min_tick_size))
    # round up tick size to nearest 1, 2, 5
    if (min_tick_size / tick_order_magn > 5) {
        tick_size <- tick_order_magn * 20
    } else if (min_tick_size / tick_order_magn > 2) {
        tick_size <- tick_order_magn * 10
    } else {
        tick_size <- tick_order_magn * 5
    }
    first_tick <- ceiling(view_start / tick_size) * tick_size

    final_plot <- subplot(plot_tracks, nrows = length(plot_tracks),
        shareX = TRUE, titleY = TRUE) %>%
        layout(
            xaxis = list(
                dtick = tick_size,
                tick0 = first_tick,
                tickmode = "linear"
            )
        )

    if (graph_mode == "Pan") {
        final_plot <- final_plot %>%
            layout(dragmode = "pan")
    } else if (graph_mode == "Zoom") {
        final_plot <- final_plot %>%
            layout(dragmode = "zoom")
    } else if (graph_mode == "Movable Labels") {
        final_plot <- final_plot %>%
            layout(dragmode = FALSE) %>%
            config(editable = TRUE)
    }

    # Zero all but last subplot
    n_plots <- length(plot_tracks) - 1

    final_plot <- final_plot %>% layout(yaxis = list(
        rangemode = "tozero", tick0 = 0))
    if (n_plots > 1)
        final_plot <- final_plot %>% layout(yaxis2 =
            list(rangemode = "tozero", tick0 = 0))

    if (n_plots > 2)
        final_plot <- final_plot %>% layout(yaxis3 =
            list(rangemode = "tozero", tick0 = 0))

    if (n_plots > 3)
        final_plot <- final_plot %>% layout(yaxis4 =
            list(rangemode = "tozero", tick0 = 0))

    if (n_plots > 4)
        final_plot <- final_plot %>% layout(yaxis5 =
            list(rangemode = "tozero", tick0 = 0))

    return(final_plot)
}
################################# PLOT TRACKS INTERNALS ########################

.internal_get_coverage_as_df <- function(samples, files, seqname, start, end,
        strand = c("*", "+", "-")) {
    strand <- match.arg(strand)
    if (!(strand %in% c("*", "+", "-"))) {
        .log(paste("In getCoverage(),",
            "Invalid strand. '*', '+' or '-'"))
    }
    covData <- list()
    for (i in seq_len(length(files))) {
        cov <- getCoverage(files[i], seqname, start - 1, end, strand)
        view <- IRanges::Views(cov, start, end)
        view.df <- as.data.frame(view[[1]])
        covData[[i]] <- view.df
    }
    df <- do.call(cbind, covData)
    colnames(df) <- samples
    x <- seq(start, end)
    df <- cbind(x, df)
    return(df)
}

bin_df <- function(df, binwidth = 3) {
    DT <- as.data.table(df)
    brks <- seq(1, nrow(DT) + 1, length.out = (nrow(DT) + 1) / binwidth)
    bin <- NULL
    DT[, c("bin") := findInterval(seq_len(nrow(DT)), brks)]
    DT2 <- DT[, lapply(.SD, mean, na.rm = TRUE), by = "bin"]
    DT2[, c("bin") := NULL]
    return(as.data.frame(DT2))
}
