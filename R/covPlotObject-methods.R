#' Container to hold ready-to-plot data for coverage plots
#'
#' This object is generated by calling ? on covDataObjects.
#' 
#' @examples
#' se <- SpliceWiz_example_NxtSE(novelSplicing = TRUE)
#'
#' # Assign annotation of the experimental conditions
#' colData(se)$treatment <- rep(c("A", "B"), each = 3)
#'
#' dataObj <- getCoverageData(
#'     se,
#'     Gene = "SRSF3",
#'     tracks = colnames(se)
#' )
#' 
#' # covPlotObject uses same parameters as covDataObject, unless arguments
#' # overridden by parameters in getPlotObject
#' plotObj_samples <- getPlotObject(
#'     dataObj,
#'     Event = "SE:SRSF3-203-exon4;SRSF3-202-int3"
#' )
#'
#' plotView(plotObj_samples)
#'
#' # Generate group plot
#' plotObj_group <- getPlotObject(
#'     dataObj,
#'     Event = "SE:SRSF3-203-exon4;SRSF3-202-int3",
#'     condition = "treatment",
#'     tracks = c("A", "B")
#' )
#'
#' plotView(plotObj_group, centerByEvent = TRUE)
#'
#' @name covPlotObject-class
#' @seealso [getCoverageData]
#' @md
NULL

covPlotObject <- function(
        args = list(),
        cov = list(),
        norm_cov = list(),
        junc = list(),
        norm_junc = list(),
        junc_PSI = list(),
        cov_stats = list(),
        annotation = list()
) {
    obj <- new("covPlotObject",
        args = args,
        cov = cov,
        norm_cov = norm_cov,
        junc = junc,
        norm_junc = norm_junc,
        junc_PSI = junc_PSI,
        cov_stats = cov_stats,
        annotation = annotation
    )
    obj
}

#' @describeIn covPlotObject-class Generates a covPlotObject object from a
#'   covDataObject. Allows users to change parameters such as viewing window,
#'   conditions, tracks, and other parameters, for customizing plot parameters
#' @export
getPlotObject <- function(
    obj, 
    Event, # To specify normalization event
    # view_start, view_end, # remove to preserve scroll flexibility
    strand = c("*", "+", "-"),
    tracks, # can be a list of iterables
    condition
    # ribbon_mode = c("sd", "ci", "sem", "none"),
) {
    args <- obj@args

    if(!missing(tracks)) args[["tracks"]] <- tracks
    if(!missing(condition)) {
        args[["condition"]] <- condition
    } else if(missing(tracks)) {
        args[["condition"]] <- NULL
    }

    if(!missing(Event)) args[["Event"]] <- Event
    if(!("Event" %in% names(args)) && "condition" %in% names(args)) {
        .log(paste("In getPlotObject,",
            "for plotting by condition, normalizing `Event` must be supplied"
        ))
    }
    
    # Check tracks and conditions in args are legit, modify as necessary
    args <- .gPO_check_tracks(obj, args)
    
    # Junction strand is always same as requested strand
    # But need to check strandedness of RNA-seq data before deciding coverage
    if(
            !missing(strand) && 
            length(strand) == 1 && 
            strand %in% c("*", "+", "-")
    ) {
        args[["strand"]] <- strand
    } else if(!("strand" %in% names(args))) {
        args[["strand"]] <- "*" # default strand
    }

    # Check strand against stranded-ness of RNA-seq
    args <- .gPO_check_strand(obj, args)

    # Always get these
    cov <- .gCD_getCoverage(obj, args)
    junc <- .gCD_getJunc(obj, args, cov)

    norm_cov <- norm_junc <- list()
    if("Event" %in% names(args)) {
         norm_cov <- .gCD_getCoverage(obj, args, normalize = TRUE)
         
         # if single sample
         norm_junc <- .gCD_getJunc(obj, args, norm_cov, normalized = TRUE)
    }

    # Plot stats if applicable
    cov_stats <- junc_PSI <- list()
    if("condition" %in% names(args)) {
        # compile junction data
        junc_PSI <- .gCD_getPSI(obj, args, norm_cov)
        cov_stats <- .gCD_covStats(norm_cov)
    }

    # plot relevant annotations
    highlight_gr <- list()
    if(
            "Event" %in% names(args) && 
            args[["Event"]] %in% rownames(obj@normData$rowData)
    ) {
        row <- obj@normData$rowData[args[["Event"]],]
        args[["EventRegion"]] <- row$EventRegion
        if (row$EventType %in% c("MXE", "SE")) {
            highlight_gr[[1]] <- coord2GR(c(row$Event1a, row$Event2a))
        } else {
            highlight_gr[[1]] <- coord2GR(row$Event1a)
        }
        if (row$EventType %in% c("MXE")) {
            highlight_gr[[2]] <- coord2GR(c(row$Event1b, row$Event2b))
        } else if (row$EventType %in%  c("SE", "A3SS", "A5SS", "ALE", "AFE")) {
            highlight_gr[[2]] <- coord2GR(row$Event1b)
        }    
    }
    args[["highlight_gr"]] <- highlight_gr

    DTlist <- obj@annotation
    DTlist$reduced.DT <- .gcd_highlight_anno(
        DTlist$reduced.DT, args[["highlight_gr"]]
    )
    
    # Filtering and stacking can be done as later steps
    
    # DTlist$reduced.DT <- .gcd_filter_anno(
        # DTlist$reduced.DT, DTlist$transcripts.DT,
        # selected_transcripts = selected_transcripts,
        # gr_expressed_junctions = NULL,
        # plot_key_isoforms = plot_key_isoforms
    # )

    # args[["condensed"]] <- condensed
    # DTplotlist <- .gCD_stack_anno(
        # DTlist, 
        # args[["view_start"]], args[["view_end"]], 
        # args[["reverseGenomeCoords"]],
        # args[["condensed"]]
    # )
    # args[["condense_this"]] <- DTplotlist[["condense_this"]]

    
    return(covPlotObject(
        args = args,
        cov = cov,
        norm_cov = norm_cov,
        junc = junc,
        norm_junc = norm_junc,
        junc_PSI = junc_PSI,
        cov_stats = cov_stats,
        annotation = DTlist
    ))
}

#' @describeIn covPlotObject-class Returns the tracks specified in the 
#'   covPlotObject object
#' @export
setMethod("tracks", c(x = "covPlotObject"), function(
    x
) {
    return(x@args[["tracks"]])
})

#' @describeIn covPlotObject-class Returns the condition specified in the 
#'   covPlotObject object
#' @export
setMethod("condition", c(x = "covPlotObject"), function(
    x
) {
    return(x@args[["condition"]])
})

#' @describeIn covPlotObject-class Returns the condition specified in the 
#'   covPlotObject object
#' @export
setMethod("getExonRanges", c(x = "covPlotObject"), function(
    x, showInteractiveExons = TRUE, reverseGenomeCoords = FALSE
) {
    args <- x@args
    args[["reverseGenomeCoords"]] <- reverseGenomeCoords
    
    fullRange <- GRanges(
        args[["view_chr"]],IRanges(args[["view_start"]], args[["view_end"]])
    )
    
    DTlist <- .pV_filterTranscripts(
        x, args,
        filterByTranscripts = "",
        filterByEventTranscripts = FALSE,
        filterByExpressedTranscripts = FALSE,
        plotRanges = fullRange
    )
    
    DTplotlist <- .gCD_stack_anno(
        DTlist,
        start(fullRange), end(fullRange),
        reverseGenomeCoords = FALSE,
        condensed = FALSE
    )
    
    if(showInteractiveExons) {
        p <- .gCD_plotRef(
            DTplotlist, fullRange, 
            reverseGenomeCoords = args[["reverseGenomeCoords"]],
            add_information = TRUE,
            interactive = showInteractiveExons,
            use_ggplotly = use_ggplotly
        )
        print(p)
    }
    
    reduced <- copy(DTplotlist$reduced.DT)
    exons <- reduced[get("type") == "exon"]
    
    return(.grDT(exons, keep.extra.columns=TRUE))
})

#' @describeIn covPlotObject-class Creates a coverage plot using the stored
#'   data in the covPlotObject
#' @export
plotView <- function(
    x, 

    # for single window view (to simplify things)
    view_start,
    view_end,
    
    debug = FALSE,
    
    oldP = covPlotly(),
    
    # Event-centric plotting
    centerByEvent = FALSE,
    EventZoomFactor = 0.2,
    EventBasesFlanking = 100,

    resolution = 5000,

    # specify tracks
    trackList = list(),
    
    # specify differential comparisons
    diff_stat = c("none", "t-test"),
    diffList = list(),

    reverseGenomeCoords = FALSE,

    ribbon_mode = c("sd", "sem", "ci", "none"),

    # plot raw or normalized coverage (only works for sample tracks)
    normalizeCoverage = FALSE,

    # specify annotation track
    plotAnnotations = TRUE,
    plotAnnoSubTrack = TRUE,

    # Plot layout
    verticalLayout = c(6,1,1,2),
    horizontalLayout = c(),

    # filter annotations
    filterByTranscripts = "",

    # plot only by transcripts with highlights
    filterByEventTranscripts = FALSE,

    # filter annotations
    filterByExpressedTranscripts = TRUE,
    
    # whether to condense transcripts by gene
    condenseTranscripts = FALSE,

    # whether to plot sashimi arcs
    plotJunctions = TRUE,
    junctionThreshold = 0.01,

    # whether to plot by exon windows
    plotRanges = GRanges(),

    # ggplot or plotly object?
    interactive = FALSE,
    interactive2 = FALSE,
    ...
) {
    use_ggplotly <- FALSE
    use_fastplotly <- TRUE
    use_DT <- TRUE

    if(!is(x, "covPlotObject")) .log(paste(
        "In plotView,", "x must be a covPlotObject"
    ))

    args <- x@args

    # inject variables into args
    if(!missing(view_start)) args[["view_start"]] <- view_start
    if(!missing(view_end)) args[["view_end"]] <- view_end
    args[["reverseGenomeCoords"]] <- reverseGenomeCoords
    
    ribbon_mode <- match.arg(ribbon_mode)
    if(!is_valid(ribbon_mode)) ribbon_mode <- "none"
    args[["ribbon_mode"]] <- ribbon_mode

    if(
            (missing(view_start) | missing(view_end)) &&
            centerByEvent &
            "EventRegion" %in% names(args)
    ) {
        args <- .pV_getEventCoords(x, args, EventZoomFactor, EventBasesFlanking)
    }
    
    diff_stat <- match.arg(diff_stat)
    if(!is_valid(diff_stat)) diff_stat <- "none"
    
    # plotRanges checking
    
    if(!is(plotRanges, "GRanges")) .log(paste(
        "In plot() for class covPlotObject,",
        "`plotRanges` must be a GRanges object"
    ))
    # Plot single window if no plotRanges given
    if(length(plotRanges) == 0) plotRanges <- GRanges(
        args[["view_chr"]],IRanges(args[["view_start"]], args[["view_end"]])
    ) # strand is ignored
    if(
        any(as.character(seqnames(plotRanges)) != args[["view_chr"]])
    ) {
        seqs <- unique(as.character(seqnames(plotRanges)))
        .log(paste(
            "In plotView() for class covPlotObject,",
            "Some elements in `plotRanges` have seqnames that do not match that",
            "of covPlotObject", seqs[!(seqs %in% args[["view_chr"]])]
        ))
    }

    # disable interactive if multi plot
    if(interactive == TRUE & length(plotRanges) > 1) {
        .log(paste(
            "In plotView,",
            "interactive plots are not supported for multi-view plotting"
        ), "warning")
        interactive <- FALSE
    }

    # What is the full range
    fullRange <- range(plotRanges)
    if(!missing(view_start) & !missing(view_end)) {
        # whatever's larger
        fullRange <- range(c(fullRange, 
            GRanges(args[["view_chr"]], IRanges(view_start, view_end))
        ))        
    }
    if(
        start(fullRange) < args[["limit_start"]] |
        end(fullRange) > args[["limit_end"]]
    ) {
        .log(paste(
            "Given range is outside that supported by parent covPlotObject.",
            "Suggest regenerating covPlotObject by calling getPlotObject()"
        ))
    }
        
    fetchRange <- fullRange
    if(interactive) {
        start(fetchRange) <- max(args[["limit_start"]], 
            start(fullRange) - width(fullRange))
        end(fetchRange) <- min(args[["limit_end"]],
            end(fullRange) + width(fullRange))
    }
        
    # Sort plotRanges
    plotRanges <- sort(plotRanges, decreasing = args[["reverseGenomeCoords"]])
    
    # Track list checking - should be a list of indices
    
    # If no trackList given, plot all tracks individually
    if(length(trackList) == 0) trackList <- lapply(
        seq_len(length(args[["tracks"]])),
        function(i) i
    )
    if(!is(trackList, "list")) {
        args[["trackList"]] <- .pV_trackList_from_vector(trackList, args)
    } else {
        args[["trackList"]] <- .pV_trackList_from_list(trackList, args)
    }

    # Structure of plot
    # | 1a || 1b || 1c |
    # | 2a || 2b || 2c |
    # | 3a || 3b || 3c |
    # | pa || pb || pc | - diff track
    # | A  || B  || C  | - annotation subtrack
    # | annotation     | - annotation full track   

    covTrack <- list()
    diffTrack <- list()
    annoSubTrack <- list()
    annoFullTrack <- list() # list of 1
    
    # Proportion all viewing frames
    widthSum <- sum(width(plotRanges))
    widthFrac <- width(plotRanges) / widthSum
    
    if(use_DT && (!interactive | use_ggplotly)) use_DT <- FALSE
    
    # bench <- system.time({
    
        # For filtering transcripts by expression later
        aggJuncCoords <- c()
        reservedCoords <- c()
        for(j in seq_len(length(plotRanges))) {
            range_gr <- plotRanges[j]
            
            # Work out which coords to plot
            juncCoords <- .cPO_getJuncCoords(
                x, args, normalizeCoverage,
                range_gr = range_gr, 
                junctionThreshold
            )
            aggJuncCoords <- c(aggJuncCoords, juncCoords)
            
            covTrack[[j]] <- .cPO_plotCoverage_multi(
                x, args, normalizeCoverage,
                range_gr = range_gr, 
                plotJunctions = plotJunctions,
                junctionThreshold = junctionThreshold,
                interactive = interactive, interactive2 = interactive2,
                use_fastplotly = use_fastplotly,
                use_DT = use_DT
            )
            
            if(diff_stat != "none" && length(diffList) > 0) {
                diffTrack[[j]] <- .cPO_plotDiff_multi(
                    x, args, diffList,
                    diff_stat, range_gr,
                    interactive = interactive,
                    interactive2 = interactive2,
                    use_fastplotly = use_fastplotly
                )
            }
        }
        reservedCoords <- sort(unique(c(
            aggJuncCoords[["jc_start"]] - 1,
            aggJuncCoords[["jc_start"]],
            aggJuncCoords[["jc_end"]],
            aggJuncCoords[["jc_end"]] + 1
        )))
    
    # })
    # message("Coverage data generation time:")
    # print(bench)
    
    # bench <- system.time({
    
        DTlist <- .pV_filterTranscripts(
            x, args,
            filterByTranscripts = filterByTranscripts,
            filterByEventTranscripts = filterByEventTranscripts,
            filterByExpressedTranscripts = filterByExpressedTranscripts,
            aggJuncCoords = aggJuncCoords
        )
        DTplotlist <- .gCD_stack_anno(
            DTlist,
            start(fetchRange), end(fetchRange),
            reverseGenomeCoords = args[["reverseGenomeCoords"]],
            condensed = condenseTranscripts
        )
        DTplotlist[["exonRanges"]] <- plotRanges

        if(plotAnnoSubTrack && length(plotRanges) > 1) {
            for(j in seq_len(length(plotRanges))) {
                range_gr <- plotRanges[j]
                
                annoSubTrack[[j]] <- .gCD_plotRef(
                    DTplotlist, range_gr,
                    reverseGenomeCoords = args[["reverseGenomeCoords"]],
                    add_information = FALSE,
                    interactive = interactive,
                    interactive2 = interactive2
                )
            }
        }
        
        if(plotAnnotations) {
            annoFullTrack[[1]] <- .gCD_plotRef(
                DTplotlist, fullRange, 
                reverseGenomeCoords = args[["reverseGenomeCoords"]],
                add_information = TRUE,
                interactive = interactive,
                interactive2 = interactive2,
                use_ggplotly = use_ggplotly,
                use_fastplotly = use_fastplotly
            )
        }

    # })
    # message("Annotation data generation time:")
    # print(bench)

    keepVLayout <- c(
        length(covTrack) > 0,
        length(diffTrack) > 0,
        length(annoSubTrack) > 0,
        length(annoFullTrack) > 0
    )
    originalVerticalLayout <- verticalLayout
    if(length(originalVerticalLayout) == 4) {
        originalVerticalLayout <- originalVerticalLayout[-3]
    }
    if(length(verticalLayout) == 4) {
        verticalLayout <- verticalLayout[keepVLayout]
    } else if(length(verticalLayout) == sum(keepVLayout)) {
        # do nothing
    } else {
        # revert to default
        verticalLayout <- c(6,1,1,2)
        verticalLayout <- verticalLayout[keepVLayout]
    }
    
    if(length(horizontalLayout) == 0) {
        horizontalLayout <- ceiling(10 * widthFrac / sum(widthFrac))
    } else if(length(horizontalLayout) == length(covTrack)) {
        horizontalLayout <- ceiling(horizontalLayout)
    } else {
        horizontalLayout <- ceiling(10 * widthFrac / sum(widthFrac))
    }
    
    if(!args[["reverseGenomeCoords"]]) {
        plotViewStart <- start(fullRange)
        plotViewEnd <- end(fullRange)
    } else {
        plotViewStart <- end(fullRange)
        plotViewEnd <- start(fullRange)
    }

    if(debug) {
        return(list(
            plotViewStart = plotViewStart, plotViewEnd = plotViewEnd,
            covTrack = covTrack,
            diffTrack = diffTrack,
            annoSubTrack = annoSubTrack,
            annoFullTrack = annoFullTrack
        ))
    }
    
    # bench <- system.time({
    
        if(interactive2) {
            if(is(oldP, "covPlotly")) {
                p <- oldP
                p@covTrack <- covTrack
                p@diffTrack <- diffTrack
                p@annoTrack <- annoFullTrack
            } else {
                p <- covPlotly(
                    covTrack = covTrack,
                    diffTrack = diffTrack,
                    annoTrack = annoFullTrack
                )
            }    

            p@args[["resolution"]] <- resolution
            p@args[["reservedCoords"]] <- reservedCoords

            p <- .pV_assemble_covPlotly2(p, originalVerticalLayout)

            p@fig[[2]] <- p@fig[[2]] %>% layout(
                dragmode = "pan",
                xaxis = list(
                    range = c(plotViewStart, plotViewEnd)
                )
            )
        } else if(interactive) {
            p <- covPlotly(
                fig = list(),
                covTrack = covTrack,
                diffTrack = diffTrack,
                annoTrack = annoFullTrack,
                vLayout = verticalLayout
            )

            p <- .pV_assemble_covPlotly(p)
            
            p@fig[[1]] <- p@fig[[1]] %>% layout(
                dragmode = "pan",
                xaxis = list(
                    range = c(plotViewStart, plotViewEnd)
                )
            )
        } else {
            p <- .pV_assemble_ggplot(
                covTrack, diffTrack, annoSubTrack, annoFullTrack,
                    verticalLayout, horizontalLayout
            )
        }
        
    # })
    # message("Plotly generation time:")
    # print(bench)
    return(p)
}

################################################################################

.pV_getEventCoords <- function(
    x, args,
    zoom_factor = 0.2,
    bases_flanking = 100
) {
    # sanitise parameters
    if(!is.numeric(bases_flanking) || bases_flanking < 0) bases_flanking <- 0
    if(!is.numeric(zoom_factor) || zoom_factor < 0) zoom_factor <- 0

    if(!("EventRegion" %in% names(args))) return(NULL)
    EventRegion <- args[["EventRegion"]]
    grEvent <- coord2GR(EventRegion)
    
    eventStart <- start(grEvent)
    eventEnd <- end(grEvent)
    view_length <- eventEnd - eventStart
    view_center <- (eventEnd + eventStart) / 2
    new_view_length <- view_length * 3^zoom_factor + 2 * bases_flanking
    
    view_start <- round(view_center - new_view_length / 2)
    view_end <- round(view_center + new_view_length / 2)
    
    seqInfo <- args[["seqInfo"]][args[["view_chr"]]]
    seqmax <- GenomeInfoDb::seqlengths(seqInfo)
    if (view_end > seqmax) {
        view_end <- seqmax - 1
        view_start <- view_end - new_view_length
        if(view_start < 1) view_start <- 1
    }
    args[["view_start"]] <- view_start
    args[["view_end"]] <- view_end
    
    return(args)
}

################################################################################

.pV_filterTranscripts <- function(
    x, args,
    filterByTranscripts,
    filterByEventTranscripts,
    filterByExpressedTranscripts,
    aggJuncCoords
) {

    # Filter annotations by observed coords
    reduced.DT <- copy(x@annotation[["reduced.DT"]])
    transcripts.DT <- copy(x@annotation[["transcripts.DT"]])
    
    transcriptFiltered <- FALSE
    if(is_valid(filterByTranscripts)) {
        if(
            all(filterByTranscripts %in% 
                c(
                    transcripts.DT$transcript_id, transcripts.DT$transcript_name
                )
            )
        ) {
            transcripts.DT <- transcripts.DT[
                get("transcript_name") %in% filterByTranscripts |
                get("transcript_id") %in% filterByTranscripts
            ]
            reduced.DT <- reduced.DT[
                get("transcript_id") %in% transcripts.DT$transcript_id
            ]
            transcriptFiltered <- TRUE
        }
    }
    
    if(!transcriptFiltered & filterByEventTranscripts) {
        reduced.DT.HL <- reduced.DT[get("highlight") != "0"]
        reduced.DT.nonHL <- reduced.DT[get("highlight") == "0"]
        reduced.DT.nonHL <- reduced.DT.nonHL[
            grepl("novel", get("transcript_id"))
        ]
        if(nrow(reduced.DT.HL) != 0) {
            transcripts.DT <- transcripts.DT[
                get("transcript_id") %in% reduced.DT.HL$transcript_id &
                
                # remove non-highlighted novel elements
                !(get("transcript_id") %in% reduced.DT.nonHL$transcript_id)
            ]
            reduced.DT <- reduced.DT[
                get("transcript_id") %in% transcripts.DT$transcript_id
            ]
            transcriptFiltered <- TRUE
        }
    }
    
    if(!transcriptFiltered && filterByExpressedTranscripts) {
        reduced.DT.introns <- reduced.DT[get("type") == "intron"]
        expressed.introns <- reduced.DT.introns[
            get("start") %in% aggJuncCoords[["jc_start"]] &
            get("end") %in% aggJuncCoords[["jc_end"]]
        ]
        nonexpressed.novel <- reduced.DT.introns[
            !(get("start") %in% aggJuncCoords[["jc_start"]]) |
            !(get("end") %in% aggJuncCoords[["jc_end"]])
        ]
        nonexpressed.novel <- nonexpressed.novel[
            grepl("novel", get("transcript_id"))
        ]
        if(nrow(expressed.introns) > 0) {
            transcripts.DT <- transcripts.DT[
                get("transcript_id") %in% expressed.introns$transcript_id &
                
                # remove non-highlighted novel elements
                !(get("transcript_id") %in% nonexpressed.novel$transcript_id)
            ]
            reduced.DT <- reduced.DT[
                get("transcript_id") %in% transcripts.DT$transcript_id
            ]
            transcriptFiltered <- TRUE
        }
    }

    return(list(
        reduced.DT = reduced.DT,
        transcripts.DT = transcripts.DT
    ))
}

################################################################################


.cPO_getJuncCoords <- function(
    x, args, 
    normalizeCoverage = FALSE,
    range_gr,
    junctionThreshold = 0.01
) {
    plotMeanCov <- FALSE
    if("condition" %in% names(args)) plotMeanCov <- TRUE

    if(normalizeCoverage) {
        if(length(x@norm_cov) == 0 || plotMeanCov) {
            normalizeCoverage <- FALSE
        }
    }
    
    trackList <- args[["trackList"]]
  
    fetch_gr <- range_gr
    start(fetch_gr) <- max(args[["limit_start"]], 
        start(range_gr) - width(range_gr))
    end(fetch_gr) <- min(args[["limit_end"]],
        end(range_gr) + width(range_gr))  

    jc_start <- c()
    jc_end <- c()
    for(track_id in seq_len(length(trackList))) {
        idx <- trackList[[track_id]]
        for(elem in args[["tracks"]][idx]) {
            if(plotMeanCov) {
                junc <- x@junc_PSI[[elem]]
            } else if(normalizeCoverage) {
                junc <- x@norm_junc[[elem]]
            } else {
                junc <- x@junc[[elem]]
            }
            OL <- findOverlaps(junc, fetch_gr)
            if(length(from(OL)) > 0) {
                junc <- junc[unique(from(OL))]
            } else {
                junc <- NULL
            } 
        
            if(!is.null(junc)) {
                isMean <- ("mean" %in% names(mcols(junc)))
                if(isMean) {
                    junc <- junc[mcols(junc)$mean >= junctionThreshold]
                } else if(normalizeCoverage) {
                    junc <- junc[mcols(junc)$count >= junctionThreshold]
                } else {
                    cov <- x@cov[[elem]]
                    junc <- junc[mcols(junc)$count >= 
                        junctionThreshold * max(cov$depth)
                    ]
                }
                if(length(junc) > 0) {
                    jc_start <- c(jc_start, start(junc))
                    jc_end <- c(jc_end, end(junc))             
                }
            }
        }
    }
    
    return(list(
        jc_start = jc_start, jc_end = jc_end
    ))
}

.cPO_plotCoverage_multi <- function(
    x, args,
    normalizeCoverage,
    range_gr,
    plotJunctions = TRUE,
    junctionThreshold = 0.01,
    interactive = FALSE, interactive2 = FALSE,
    use_fastplotly = FALSE,
    use_DT = FALSE
) {
    plotMeanCov <- FALSE
    if("condition" %in% names(args)) plotMeanCov <- TRUE
    
    rb <- "none"
    if(plotMeanCov) rb <- args[["ribbon_mode"]]

    if(normalizeCoverage) {
        if(length(x@norm_cov) == 0 || plotMeanCov) {
            normalizeCoverage <- FALSE
        }
    }
    
    # junction processing is identical
    trackName <- "Coverage"
    
    trackList <- args[["trackList"]]
  
    # plot view x cartesian coordinates
    if(args[["reverseGenomeCoords"]]) {
        plotViewStart <- end(range_gr)
        plotViewEnd <- start(range_gr)
    } else {
        plotViewStart <- start(range_gr)
        plotViewEnd <- end(range_gr)            
    }
    
    # fetchViewStart and fetchViewEnd determine how much coverage to fetch
    # best to fetch a bit more than we need
    fetch_gr <- range_gr
    start(fetch_gr) <- max(args[["limit_start"]], 
        start(range_gr) - width(range_gr))
    end(fetch_gr) <- min(args[["limit_end"]],
        end(range_gr) + width(range_gr))  

    DT_list <- list()
    DTJn_list <- list()
    for(track_id in seq_len(length(trackList))) {
        idx <- trackList[[track_id]]
        for(elem in args[["tracks"]][idx]) {
            if(plotJunctions) {
                if(plotMeanCov) {
                    junc <- x@junc_PSI[[elem]]
                } else if(normalizeCoverage) {
                    junc <- x@norm_junc[[elem]]
                } else {
                    junc <- x@junc[[elem]]
                }
                OL <- findOverlaps(junc, fetch_gr)
                if(length(from(OL)) > 0) {
                    junc <- junc[unique(from(OL))]
                } else {
                    junc <- NULL
                }        
            } else {
                junc <- NULL
            }

            if(plotMeanCov) {
                groupName <- paste(x@args[["condition"]], elem)
                DT <- x@cov_stats[[elem]]
                DT_sub <- DT[,seq_len(2)] # only 2 columns

                DTJn <- c()
                if(!is.null(junc)) {
                    DTJn <- .cPO_jn_arcs(
                        junc,
                        arcHeight = 0.1 * max(DT$mean),
                        junctionThreshold = junctionThreshold * max(DT$mean)
                    )            
                }
            } else {
                groupName <- elem
                if(normalizeCoverage) {
                    DT <- x@norm_cov[[elem]]                   
                } else {
                    DT <- x@cov[[elem]]
                }
                
                DTJn <- c()
                if(!is.null(junc)) {
                    DTJn <- .cPO_jn_arcs(
                        junc, 
                        arcHeight = 
                            0.1 * max(DT$depth),
                        junctionThreshold = junctionThreshold * 
                            max(DT$depth)
                    )
                }
            }
            DT$group <- groupName
            DT$covTrack <- names(trackList)[track_id]
            DT_list[[groupName]] <- DT

            if(!is.null(junc) && nrow(DTJn) > 0) {
                DTJn$group <- groupName
                DTJn$covTrack <- names(trackList)[track_id]
                DTJn_list[[groupName]] <- DTJn
            }
        }
    }
    
    if(use_DT) {
        df_all <- rbindlist(DT_list)
        dfJn_all <- rbindlist(DTJn_list) 
    } else {
        df_all <- as.data.frame(rbindlist(DT_list))
        dfJn_all <- as.data.frame(rbindlist(DTJn_list))    
    }

    # group annotation
    if(interactive2) {
        df_all$info <- ""
    } else if(interactive) {
        if(plotMeanCov) {
            if(rb %in% c("ci", "sd", "sem")) {
                df_all$info <- paste(
                    paste0(df_all$group, ":"),
                    paste0("Coordinate: ", df_all$x), 
                    paste0("Norm-Depth (mean): ", round(df_all$mean, 4)),
                    paste0("Norm-Depth (", rb, "): ", 
                        round(df_all[, rb], 4)),
                    sep = "\n"
                )
            } else {
                df_all$info <- paste(
                    paste0(df_all$group, ":"),
                    paste0("Coordinate: ", df_all$x), 
                    paste0("Norm-Depth (mean): ", round(df_all$mean, 4)),
                    sep = "\n"
                )
            }
        } else {
            df_all$info <- paste(
                paste0(df_all$group, ":"),
                paste0("Coordinate: ", df_all$x), 
                paste0("Depth: ", df_all$depth),
                sep = "\n"
            )
        }
    } else {
        # disable annotation for static plots
        df_all$info <- ""
    }

    # junc processing - common
    dfJnSum_list <- list()
    if(plotJunctions) {
        dtJn_all <- as.data.table(dfJn_all)
        allGroups <- unique(dtJn_all$group)
        for(elem in allGroups) {
            dtJn <- copy(dtJn_all[get("group") == elem])

            dtJn <- dtJn[
                get("x") >= start(range_gr) &
                get("x") <= end(range_gr)
            ]
            dtJn[, c("xlabel", "ylabel") := list(
                mean(get("x")), mean(get("ytmp"))), 
                by = "info"
            ]
            dtJn <- unique(
                dtJn[, 
                    c("info", "value", "xlabel", "ylabel", "group", "covTrack"), 
                    with = FALSE
                ]
            )
            dfJnSum_list[[elem]] <- dtJn
        }
    }
    if(use_DT) {
        dfJnSum_all <- rbindlist(dfJnSum_list)
    } else {
        dfJnSum_all <- as.data.frame(rbindlist(dfJnSum_list))    
    }

    # factor covTrack
    df_all$covTrack <- factor(df_all$covTrack, names(trackList))
    if(nrow(dfJn_all) > 0) {
        dfJn_all$covTrack <- factor(dfJn_all$covTrack, names(trackList))
    }
    if(nrow(dfJnSum_all) > 0) {
        dfJnSum_all$covTrack <- factor(dfJnSum_all$covTrack, names(trackList))
    }
    
    if(!interactive) {
        p <- .pV_seed_ggplot_covTrack(
            plotViewStart, plotViewEnd,
            df_all, dfJn_all, dfJnSum_all,
            plotJunctions, plotMeanCov, rb
        )
    } else if(interactive2) {
        p <- .pV_seed_fastplotly2_covTrack(
            plotViewStart, plotViewEnd,
            df_all, dfJn_all, dfJnSum_all,
            plotJunctions, plotMeanCov, rb
        )
    } else if(use_fastplotly) {
        p <- .pV_seed_fastplotly_covTrack(
            plotViewStart, plotViewEnd,
            df_all, dfJn_all, dfJnSum_all,
            plotJunctions, plotMeanCov, rb
        )
    } else {
        p <- .pV_seed_plotly_covTrack(
            plotViewStart, plotViewEnd,
            df_all, dfJn_all, dfJnSum_all,
            plotJunctions, plotMeanCov, rb
        )
    }

    return(p)
}

.cPO_plotDiff_multi <- function(
    x, args, diffList,
    diff_stat,
    range_gr,
    interactive = FALSE, interactive2 = FALSE,
    use_fastplotly = TRUE
) {  
    # plot view x cartesian coordinates
    if(args[["reverseGenomeCoords"]]) {
        plotViewStart <- end(range_gr)
        plotViewEnd <- start(range_gr)
    } else {
        plotViewStart <- start(range_gr)
        plotViewEnd <- end(range_gr)            
    }
    
    # fetchViewStart and fetchViewEnd determine how much coverage to fetch
    # best to fetch a bit more than we need
    fetch_gr <- range_gr
    start(fetch_gr) <- max(args[["limit_start"]], 
        start(range_gr) - width(range_gr))
    end(fetch_gr) <- min(args[["limit_end"]],
        end(range_gr) + width(range_gr))  
        
    # Assume diffList is a list
    if(is.null(names(diffList))) {
        listNames <- character(length(diffList))
        for(i in seq_len(length(diffList))) {
            listNames[i] <- paste(diffList[[i]], collapse = "_vs_")
        }
        names(diffList) <- listNames
    } else {
        listNames <- names(diffList)
        for(i in seq_len(listNames)) {
            if(listNames[i] == "") {
                listNames[i] <- paste(diffList[[i]], collapse = "_vs_")
            }
        }
        names(diffList) <- listNames
    }
    
    #
    df_list <- list()
    for(i in seq_len(length(diffList))) {
        df <- c()
        
        diffItem <- diffList[[i]]
        diffName <- names(diffList)[i]
        if(length(diffItem) == 2) {
            if(
                    is.vector(diffItem, "character") &&
                    all(diffItem %in% names(x@norm_cov))
            ) {
                # Assume these are track names
                cov1 <- x@norm_cov[[diffItem[1]]]
                cov2 <- x@norm_cov[[diffItem[2]]]
            } else if(
                    is.vector(diffItem, "numeric") &&
                    all(diffItem %in% seq_len(length(x@norm_cov)))
            ) {
                cov1 <- x@norm_cov[[diffItem[1]]]
                cov2 <- x@norm_cov[[diffItem[2]]]
            } else {
                next # ignore this
            }
        } else {
            next # ignore this
        }

        cov1 <- cov1[get("x") >= start(fetch_gr) & get("x") <= end(fetch_gr)]
        cov2 <- cov2[get("x") >= start(fetch_gr) & get("x") <= end(fetch_gr)]
        
        if(diff_stat == "t-test") {
            df <- .gCD_ttest(cov1, cov2)
        } else {
            next
        }
        if(!is.null(df)) {
            df$diffTrack <- diffName
            df_list[[diffName]] <- df        
        }
    }
    df_all <- as.data.frame(rbindlist(df_list))

    if(nrow(df_all) == 0) return(NULL)

    # group annotation
    if(interactive) {
        df_all$info <- paste(
            paste0(df_all$diffTrack, ":"),
            paste0("Coordinate: ", df_all$x), 
            paste0(diff_stat, " (-log10 P): ", df_all$stat),
            sep = "\n"
        )
    } else {
        # disable annotation for static plots
        df_all$info <- ""
    }

# factor covTrack
    df_all$diffTrack <- factor(df_all$diffTrack, names(diffList))

    if(!interactive) {
        p <- .pV_seed_ggplot_diffTrack(
            plotViewStart, plotViewEnd,
            df_all, diff_stat
        )
    } else if (interactive2) {
        p <- .pV_seed_fastplotly2_diffTrack(
            plotViewStart, plotViewEnd,
            df_all, diff_stat
        )
    } else if (use_fastplotly) {
        p <- .pV_seed_fastplotly_diffTrack(
            plotViewStart, plotViewEnd,
            df_all, diff_stat
        )
    } else {
        p <- .pV_seed_plotly_diffTrack(
            plotViewStart, plotViewEnd,
            df_all, diff_stat
        )
    }
    return(p)
}

################################################################################

.pV_seed_ggplot_covTrack <- function(
    plotViewStart, plotViewEnd,
    df_all, dfJn_all, dfJnSum_all,
    plotJunctions, plotMeanCov, rb
) {
    suppressWarnings({
        p <- ggplot(df_all, aes(
            text = get("info")
        )) + geom_hline(yintercept = 0)            
    })

    # plot ribbon (group cov only)
    if(plotMeanCov && rb %in% c("ci", "sd", "sem")) {
        p <- p +
            geom_ribbon(data = df_all, alpha = 0.2,
                aes(
                    x = get("x"), y = get("mean"),
                    ymin = get("mean") - get(rb),
                    ymax = get("mean") + get(rb),
                    group = get("group"),
                    fill = get("group")
                )
            )
    }
    
    # plot line
    if(plotMeanCov) {
        p <- p + geom_line(aes(
            x = get("x"), y = get("mean"), 
            group = get("group"), color = get("group")
        ))
    } else {
        p <- p + geom_line(aes(
            x = get("x"), y = get("depth"), 
            group = get("group"), color = get("group")
        ))
    }

    # plot junctions
    if(plotJunctions) {
        p <- p +
            geom_line(
                data = dfJn_all, 
                aes(x = get("x"), y = get("yarc"), group = get("info")), 
                color = "darkred"
            ) +
            geom_text(
                data = dfJnSum_all, 
                aes(
                    x = get("xlabel"), y = get("ylabel"), label = get("value")
                )
            )
    }

    p <- p + facet_grid(
        rows = "covTrack", 
        scales = "free_y", switch = "y"
    )
    
    p <- p + theme_white_legend +
        theme(axis.title.x = element_blank()) +
        labs(x = "", y = "Coverage")

    p <- p + coord_cartesian(
        xlim = c(plotViewStart, plotViewEnd),
        # ylim = yrange,
        expand = FALSE
    )
    
    return(p)
}

.pV_seed_plotly_covTrack <- function(
    plotViewStart, plotViewEnd,
    df_all, dfJn_all, dfJnSum_all,
    plotJunctions, plotMeanCov, rb
) {
    covTrack <- levels(df_all$covTrack)

    p_list <- list()
    
    for(i in seq_len(length(covTrack))) {
        track <- covTrack[i]
        df <- df_all[df_all$covTrack == track,]
        dfJn <- dfJn_all[dfJn_all$covTrack == track,]
        dfJnSum <- dfJnSum_all[dfJnSum_all$covTrack == track,]
        
        groupNames <- unique(df$group)
        nGroups <- length(groupNames)
        if(nrow(df) > 0) {
            df$group <- factor(df$group, groupNames)
        }
        if(nrow(dfJn) > 0) {
            dfJn$group <- factor(dfJn$group, groupNames)
        }
        if(nrow(dfJnSum) > 0) {
            dfJnSum$group <- factor(dfJnSum$group, groupNames)
        }

        fig <- plot_ly()
        cols <- scales::hue_pal()(nGroups)
        if(nGroups == 1) cols <- "#000000"
        if("mean" %in% colnames(df)) {
            fig <- fig %>% add_trace(
                data = df,
                x = as.formula("~x"),
                y = as.formula("~mean"),
                text = as.formula("~info"),
                hoveron = "points", hoverinfo = 'text',
                colors = cols,
                color = as.formula("~as.factor(group)"),
                type = 'scatter', mode = 'lines',
                showlegend = (nGroups>1)
            )
            if(rb %in% c("ci", "sd", "sem")) {
                fig <- fig %>% add_ribbons(
                    data = df,
                    x = as.formula("~x"),
                    ymin = as.formula(paste("~mean-", rb)),
                    ymax = as.formula(paste("~mean+", rb)),
                    text = as.formula("~info"),
                    hoveron = "points", hoverinfo = 'text',
                    colors = cols,
                    color = as.formula("~as.factor(group)"),
                    opacity = 0.2,
                    showlegend = FALSE
                )
            }
        } else {
            fig <- fig %>% add_trace(
                data = df,
                x = as.formula("~x"),
                y = as.formula("~depth"),
                text = as.formula("~info"),
                hoveron = "points", hoverinfo = 'text',
                colors = cols,
                color = as.formula("~as.factor(group)"),
                type = 'scatter', mode = 'lines',
                showlegend = (nGroups>1)
            )
        }

        if(plotJunctions & nGroups == 1) {
            dfJn_summa <- dfJn %>% group_by("info")
            fig <- fig %>% add_trace(
                data = dfJn_summa,
                x = as.formula("~x"),
                y = as.formula("~yarc"),
                text = as.formula("~info"),
                hoveron = "points", hoverinfo = 'text',
                line = list(color = 'rgb(255, 100, 100)', width = 0.5),
                type = 'scatter', mode = 'lines',
                    showlegend = FALSE
            )

            fig <- fig %>% add_trace(
                data = dfJnSum,
                x = as.formula("~xlabel"),
                y = as.formula("~ylabel"),
                text = as.formula("~value"),
                hoverinfo = 'text',
                type = 'scatter', mode = 'text',
                textposition = 'middle',
                    showlegend = FALSE
            )
        }

        # what is yrange?
        df_sub <- df[
            df$x >= min(plotViewStart, plotViewEnd) & 
            df$x <= max(plotViewStart, plotViewEnd),
        ]
        if("mean" %in% colnames(df_sub)) {
            ymax <- max(df_sub$mean)
        } else {
            ymax <- max(df_sub$depth)
        }
        fig <- fig %>%
            layout(
                yaxis = list(
                    range = c(0, ymax * 1.2),
                    title = track, fixedrange = TRUE
                )
            )
        p_list[[track]] <- fig
    }
    return(p_list)
}

.plotly_store_info <- function(x, y, text = "") {
    return(list(
        x = x, y = y, text = text
    ))
}

.pV_seed_fastplotly_covTrack <- function(
    plotViewStart, plotViewEnd,
    df_all, dfJn_all, dfJnSum_all,
    plotJunctions, plotMeanCov, rb
) {
    covTrack <- levels(df_all$covTrack)
    
    dataList <- list()
    dataCount <- 0
    
    plotList <- list()   
    
    spoof_df <- data.frame(x = 1, y = 1, text = "a")
    
    for(i in seq_len(length(covTrack))) {
        track <- covTrack[i]
        df <- df_all[df_all$covTrack == track,]
        dfJn <- dfJn_all[dfJn_all$covTrack == track,]
        dfJnSum <- dfJnSum_all[dfJnSum_all$covTrack == track,]
        
        groupNames <- unique(df$group)
        nGroups <- length(groupNames)
        if(nrow(df) > 0) {
            df$group <- factor(df$group, groupNames)
        }
        if(nrow(dfJn) > 0) {
            dfJn$group <- factor(dfJn$group, groupNames)
        }
        if(nrow(dfJnSum) > 0) {
            dfJnSum$group <- factor(dfJnSum$group, groupNames)
        }

        fig <- plot_ly()
        cols <- scales::hue_pal()(nGroups)
        if(nGroups == 1) cols <- "#000000"
        for(j in seq_len(nGroups)) {
            df_sub <- df[df$group == levels(df$group)[j],]
            if("mean" %in% colnames(df)) {
                dataCount <- dataCount + 1
                dataList[[dataCount]] <- .plotly_store_info(
                    x = df_sub$x, y = df_sub$mean, text = df_sub$info
                )
                fig <- fig %>% add_trace(
                    data = spoof_df,
                    x = as.formula("~x"),
                    y = as.formula("~y"),
                    text = as.formula("~text"),
                    hoveron = "points", hoverinfo = 'text',
                    line = list(color = cols[j]),
                    type = 'scatter', mode = 'lines',
                    showlegend = (nGroups>1)
                )
                if(rb %in% c("ci", "sd", "sem")) {
                    dataCount <- dataCount + 1
                    dataList[[dataCount]] <- .plotly_store_info(
                        x = c(df_sub$x, rev(df_sub$x)), 
                        y = c(
                            df_sub$mean + unname(unlist(df_sub[,rb])),
                            rev(df_sub$mean - unname(unlist(df_sub[,rb])))
                        ), 
                        text = c(df_sub$info, rev(df_sub$info))
                    )
                    fig <- fig %>% add_ribbons(
                        data = spoof_df,
                        x = as.formula("~x"),
                        ymin = as.formula("~y"),
                        ymax = as.formula("~y"),
                        text = as.formula("~text"),
                        hoveron = "points", hoverinfo = 'text',
                        line = list(color = cols[j]),
                        opacity = 0.2,
                        showlegend = FALSE
                    )
                }
            } else {
                dataCount <- dataCount + 1
                dataList[[dataCount]] <- .plotly_store_info(
                    x = df_sub$x, y = df_sub$depth, text = df_sub$info
                )
                fig <- fig %>% add_trace(
                    data = spoof_df,
                    x = as.formula("~x"),
                    y = as.formula("~y"),
                    text = as.formula("~text"),
                    hoveron = "points", hoverinfo = 'text',
                    line = list(color = cols[j]),
                    type = 'scatter', mode = 'lines',
                    showlegend = (nGroups>1)
                )
            }
        }

        if(plotJunctions & nGroups == 1) {
            # sashimi arcs
            plotJuncData <- .plotly_makeJuncCurveData(
                dfJn$x, dfJn$yarc, dfJn$info
            )
            dataCount <- dataCount + 1
            dataList[[dataCount]] <- .plotly_store_info(
                x = plotJuncData$x, y = plotJuncData$y, 
                text = plotJuncData$text
            )
            fig <- fig %>% add_trace(
                data = spoof_df,
                x = as.formula("~x"),
                y = as.formula("~y"),
                text = as.formula("~text"),
                hoveron = "points", hoverinfo = 'text',
                line = list(color = 'rgb(255, 100, 100)', width = 0.5),
                type = 'scatter', mode = 'lines',
                showlegend = FALSE
            )

            # sashimi numbers
            dataCount <- dataCount + 1
            dataList[[dataCount]] <- .plotly_store_info(
                x = dfJnSum$xlabel, y = dfJnSum$ylabel, 
                text = dfJnSum$value
            )
            fig <- fig %>% add_trace(
                data = spoof_df,
                x = as.formula("~x"),
                y = as.formula("~y"),
                text = as.formula("~text"),
                hoverinfo = 'text',
                type = 'scatter', mode = 'text',
                textposition = 'middle',
                showlegend = FALSE
            )
        }

        # what is yrange?
        df_sub <- df[
            df$x >= min(plotViewStart, plotViewEnd) & 
            df$x <= max(plotViewStart, plotViewEnd),
        ]
        if("mean" %in% colnames(df_sub)) {
            ymax <- max(df_sub$mean)
        } else {
            ymax <- max(df_sub$depth)
        }
        fig <- fig %>%
            layout(
                yaxis = list(
                    range = c(0, ymax * 1.2),
                    title = track, fixedrange = TRUE
                )
            )

        plotList[[track]] <- fig
    }

    # knit subplot here
    pl_final <- subplot(
        plotList, nrows = length(plotList), 
        shareX = TRUE, titleY = TRUE
    )

    return(list(
        plot = pl_final,
        data = dataList
    ))
}

.pV_seed_fastplotly2_covTrack <- function(
    plotViewStart, plotViewEnd,
    df_all, dfJn_all, dfJnSum_all,
    plotJunctions, plotMeanCov, rb
) {
    covTrack <- levels(df_all$covTrack)
    
    # nested list of data
    dataList <- list()


    # y axis range, title
    layoutList <- list()

    for(i in seq_len(length(covTrack))) {   
        track <- covTrack[i]
        df <- df_all[df_all$covTrack == track,]
        dfJn <- dfJn_all[dfJn_all$covTrack == track,]
        dfJnSum <- dfJnSum_all[dfJnSum_all$covTrack == track,]
        
        groupNames <- unique(df$group)
        nGroups <- length(groupNames)
        if(nrow(df) > 0) {
            df$group <- factor(df$group, groupNames)
        }
        if(nrow(dfJn) > 0) {
            dfJn$group <- factor(dfJn$group, groupNames)
        }
        if(nrow(dfJnSum) > 0) {
            dfJnSum$group <- factor(dfJnSum$group, groupNames)
        }
        
        dataList[[i]] <- list()
        dataList[[i]][[1]] <- list() # always have junction track
        for(j in seq_len(nGroups)) {
            dataList[[i]][[2*j]] <- list()
            dataList[[i]][[2*j + 1]] <- list()
        }

        if(plotJunctions & nGroups == 1) {
            # sashimi arcs
            plotJuncData <- .plotly_makeJuncCurveData(
                dfJn$x, dfJn$yarc, dfJn$info
            )
            dataList[[i]][[1]] <- .plotly_store_info(
                x = plotJuncData$x, y = plotJuncData$y, 
                text = plotJuncData$text
            )

            # sashimi numbers
            dataList[[i]][[2]] <- .plotly_store_info(
                x = dfJnSum$xlabel, y = dfJnSum$ylabel, 
                text = dfJnSum$value
            )
        }

        for(j in seq_len(nGroups)) {
            df_sub <- df[df$group == levels(df$group)[j],]
            if("mean" %in% colnames(df)) {
                dataList[[i]][[2*j + 1]] <- .plotly_store_info(
                    x = df_sub$x, y = df_sub$mean, text = df_sub$info
                )
                dataList[[i]][[2*j + 1]][["hovertemplate"]] <- paste0(
                    "<b>", levels(df$group)[j], "</b><br>",
                    "<i>Coordinate:</i> %{x}<br>",
                    "<i>Norm-Depth (mean):</i> %{y:.3f}<br>",
                    "<extra></extra>"
                )
                if(nGroups > 1) dataList[[i]][[2*j + 1]][["showlegend"]] <- TRUE
                if(rb %in% c("ci", "sd", "sem")) {
                    dataList[[i]][[2*j + 2]] <- .plotly_store_info(
                        x = c(df_sub$x, rev(df_sub$x)), 
                        y = c(
                            df_sub$mean + unname(unlist(df_sub[,rb])),
                            rev(df_sub$mean - unname(unlist(df_sub[,rb])))
                        ), 
                        text = c(df_sub$info, rev(df_sub$info))
                    )
                    dataList[[i]][[2*j + 2]][["hovertemplate"]] <- paste0(
                        "<b>", levels(df$group)[j], "</b><br>",
                        "<i>Coordinate:</i> %{x}<br>",
                        "<i>Norm-Depth (", rb,"):</i> %{y:.3f}<br>",
                    "<extra></extra>"
                    )
                } else {
                    dataList[[i]][[2*j + 2]] <- list()
                }
            } else {
                dataList[[i]][[2*j + 1]] <- .plotly_store_info(
                    x = df_sub$x, y = df_sub$depth, text = df_sub$info
                )
                dataList[[i]][[2*j + 1]][["hovertemplate"]] <- paste0(
                    "<b>", levels(df$group)[j], "</b><br>",
                    "<i>Coordinate:</i> %{x}<br>",
                    "<i>Depth:</i> %{y}<br>",
                    "<extra></extra>"
                )
                dataList[[i]][[2*j + 2]] <- list()
            }
        }

        # what is yrange?
        df_sub <- df[
            df$x >= min(plotViewStart, plotViewEnd) & 
            df$x <= max(plotViewStart, plotViewEnd),
        ]
        if("mean" %in% colnames(df_sub)) {
            ymax <- max(df_sub$mean)
        } else {
            ymax <- max(df_sub$depth)
        }
        layoutList[[i]] <- list(
            yrange = c(0, ymax * 1.2),
            title = track
        )
    }

    return(list(
        dataList = dataList,
        layoutList = layoutList
    ))
}

.pV_seed_ggplot_diffTrack <- function(
    plotViewStart, plotViewEnd, df_all, diff_stat
) {
    diffTrack <- levels(df_all$diffTrack)
    
    # plotting - common        
    suppressWarnings({
        p <- ggplot(df_all, aes(
            text = get("info")
        )) + geom_hline(yintercept = 0)            
    })
    
    # plot line
    p <- p + geom_line(aes(
        x = get("x"), y = get("stat"), 
        group = get("diffTrack"), color = get("diffTrack")
    ))

    # plot y axis and format
    p <- p + theme_white_legend + labs(y = "-log10 P")

    p <- p + facet_grid(
        rows = "diffTrack", 
        scales = "free_y", switch = "y"
    )
    
    p <- p +
        theme(axis.title.x = element_blank()) +
        labs(
            x = "", y = diff_stat
        )

    p <- p + coord_cartesian(
        xlim = c(plotViewStart, plotViewEnd),
        expand = FALSE
    )     
    
    return(p)
}

.pV_seed_plotly_diffTrack <- function(
    plotViewStart, plotViewEnd, df_all, diff_stat
) {
    diffTrack <- levels(df_all$diffTrack)

    p_list <- list()
    
    for(i in seq_len(length(diffTrack))) {
        track <- diffTrack[i]
        df <- df_all[df_all$diffTrack == track,]
        
        fig <- plot_ly()
        
        fig <- fig %>% add_trace(
            data = df,
            x = as.formula("~x"),
            y = as.formula("~stat"),
            colors = "#000000",
            type = 'scatter', mode = 'lines',
            showlegend = FALSE
        )
        
        df_sub <- df[
            df$x >= min(plotViewStart, plotViewEnd) & 
            df$x <= max(plotViewStart, plotViewEnd),
        ]
        ymax <- max(df_sub$stat)
        fig <- fig %>%
            layout(
                yaxis = list(
                    range = c(0, ymax * 1.2),
                    title = "-log10 P", fixedrange = TRUE
                )
            )
        p_list[[track]] <- fig
    }
    return(p_list)
}

.pV_seed_fastplotly_diffTrack <- function(
    plotViewStart, plotViewEnd, df_all, diff_stat
) {
    diffTrack <- levels(df_all$diffTrack)

    dataList <- list()
    dataCount <- 0
    
    plotList <- list()   
    
    spoof_df <- data.frame(x = 1, y = 1, text = "a")
    
    for(i in seq_len(length(diffTrack))) {
        track <- diffTrack[i]
        df <- df_all[df_all$diffTrack == track,]
        
        fig <- plot_ly()

        dataCount <- dataCount + 1
        dataList[[dataCount]] <- .plotly_store_info(
            x = df$x, y = df$stat, text = df$info
        )
        fig <- fig %>% add_trace(
            data = spoof_df,
            x = as.formula("~x"),
            y = as.formula("~y"),
            text = as.formula("~text"),
            hoveron = "points", hoverinfo = 'text',
            line = list(color = "#000000"),
            type = 'scatter', mode = 'lines',
            showlegend = FALSE
        )

        df_sub <- df[
            df$x >= min(plotViewStart, plotViewEnd) & 
            df$x <= max(plotViewStart, plotViewEnd),
        ]
        ymax <- max(df_sub$stat)
        fig <- fig %>%
            layout(
                yaxis = list(
                    range = c(0, ymax * 1.2),
                    title = "-log10 P", fixedrange = TRUE
                )
            )
        plotList[[track]] <- fig
    }
    
    # knit subplot here
    pl_final <- subplot(
        plotList, nrows = length(plotList), 
        shareX = TRUE, titleY = TRUE
    )

    return(list(
        plot = pl_final,
        data = dataList
    ))
}

.pV_seed_fastplotly2_diffTrack <- function(
    plotViewStart, plotViewEnd, df_all, diff_stat
) {
    diffTrack <- levels(df_all$diffTrack)

    # nested list of data
    dataList <- list()
    
    # y axis range, title
    layoutList <- list()
    
    for(i in seq_len(length(diffTrack))) {
        track <- diffTrack[i]
        df <- df_all[df_all$diffTrack == track,]
        
        dataList[[i]] <- list()
        dataList[[i]][[1]] <- .plotly_store_info(
            x = df$x, y = df$stat, text = df$info
        )
        dataList[[i]][[1]][["hovertemplate"]] <- paste0(
            "<b>", track, "</b><br>",
            "<i>Coordinate:</i> %{x}<br>",
            "<i>-log10(P):</i> %{y}<br>",
            "<extra></extra>"
        )
        df_sub <- df[
            df$x >= min(plotViewStart, plotViewEnd) & 
            df$x <= max(plotViewStart, plotViewEnd),
        ]
        ymax <- max(df_sub$stat)

        layoutList[[i]] <- list(
            yrange = c(0, ymax * 1.2),
            title = track
        )
    }

    return(list(
        dataList = dataList,
        layoutList = layoutList
    ))
}


################################################################################

.gCD_plotRef <- function(
    DTplotlist, view_gr, 
    reverseGenomeCoords = FALSE,
    add_information = TRUE,
    interactive = FALSE,
    interactive2 = FALSE,
    use_ggplotly = FALSE,
    use_fastplotly = TRUE
) {
    view_chr <- as.character(seqnames(view_gr))
    view_start <- start(view_gr)
    view_end <- end(view_gr)

    group.DT <- copy(DTplotlist$group.DT)

    # use one paste function
    if(add_information) {
        group.DT[, c("left_extra", "right_extra") := list("","")]
        if(reverseGenomeCoords) {
            group.DT[get("strand") == "-", c("right_extra") := " -->"]
            group.DT[get("strand") == "+", c("left_extra") := "<-- "]
        } else {
            group.DT[get("strand") == "+", c("right_extra") := " -->"]
            group.DT[get("strand") == "-", c("left_extra") := "<-- "]
        }
        group.DT[, c("display_name") := paste0(
            get("left_extra"), 
            get("group_name"),
            " (", get("strand"), ") ",
            get("group_biotype"),
            get("right_extra")
        )]
        group.DT[, c("left_extra", "right_extra") := list(NULL,NULL)]

        group.DT[, c("disp_x") := 0.5 * (get("start") + get("end"))]
        group.DT[get("start") < view_start & get("end") > view_start,
            c("disp_x") := 0.5 * (view_start + get("end"))]
        group.DT[get("end") > view_end & get("start") < view_end,
            c("disp_x") := 0.5 * (get("start") + view_end)]
        group.DT[get("start") < view_start & get("end") > view_end,
            c("disp_x") := 0.5 * (view_start + view_end)]    
    }

    reduced <- copy(DTplotlist$reduced.DT)
    reduced <- reduced[!is.na(reduced$plot_level)]
    condense_this <- DTplotlist$condense_this
    exonRanges <- DTplotlist$exonRanges

    # Hover Text annotation
    reduced[, c("Information") := ""]
    reduced[get("type") %in% c("exon", "CDS"), c("Information") := paste(
        paste(get("transcript_id"), "exon", get("aux_id")),
        paste0("(", get("feature_id"), ")"),
        paste0(get("seqnames"), ":", get("start"), "-", get("end"), "/", 
            get("strand")),
        sep = "\n"
    )]
    reduced[get("type") == "intron", c("Information") := paste(
        get("feature_id"), 
        paste0(get("seqnames"), ":", get("start"), "-", get("end"), "/", 
            get("strand")),
        sep = "\n"
    )]
    
    reduced <- as.data.frame(reduced)

    if (nrow(subset(reduced, type = "intron")) > 0) {
        reducedIntrons <- reduced[reduced$type == "intron", ]
        reducedIntronsExpanded <- c()
        for(i in seq_len(nrow(reducedIntrons))) {
            reducedIntronsExpanded <- rbind(reducedIntronsExpanded, data.frame(
                start = seq(reducedIntrons$start[i], reducedIntrons$end[i],
                    length.out = 10),
                end = seq(reducedIntrons$start[i], reducedIntrons$end[i],
                    length.out = 10),
                plot_level = reducedIntrons$plot_level[i],
                highlight = reducedIntrons$highlight[i],
                Information = reducedIntrons$Information[i]              
            ))
        }
        col_highlights <- sort(unique(reducedIntronsExpanded$highlight))
    }
    nonIntrons <- reduced[reduced$type != "intron", ]
    fill_highlights <- sort(unique(nonIntrons$highlight))

    if(!reverseGenomeCoords) {
        plotViewStart <- view_start
        plotViewEnd <- view_end
    } else {
        plotViewStart <- view_end
        plotViewEnd <- view_start     
    }

    if(!interactive) {
        p <- .pV_seed_ggplot_annoTrack(
            plotViewStart, plotViewEnd, view_chr,
            reducedIntronsExpanded, nonIntrons,
            group.DT, condense_this, add_information
        )
    } else if(use_ggplotly) {
        p <- .pV_seed_ggplotly_annoTrack(
            plotViewStart, plotViewEnd, view_chr,
            reducedIntronsExpanded, nonIntrons,
            group.DT, condense_this, add_information
        )
    } else if(interactive2) {
        p <- .pV_seed_fastplotly2_annoTrack(
            plotViewStart, plotViewEnd, view_chr,
            reducedIntrons, nonIntrons,
            group.DT, condense_this, add_information
        )
    } else if(use_fastplotly) {
        p <- .pV_seed_fastplotly_annoTrack(
            plotViewStart, plotViewEnd, view_chr,
            reducedIntrons, nonIntrons,
            group.DT, condense_this, add_information
        )
    } else {
        p <- .pV_seed_plotly_annoTrack(
            plotViewStart, plotViewEnd, view_chr,
            reducedIntrons, nonIntrons,
            group.DT, condense_this, add_information
        )
    }

    return(p)
}

.pV_highlight_to_colors <- function(highlights, usePlotly = FALSE) {
    if(usePlotly) {
        highlights <- sub("0", "rgba(0,0,0,1)", highlights)
        highlights <- sub("1", "rgba(0,0,255,1)", highlights)
        highlights <- sub("2", "rgba(255,0,0,1)", highlights)
        highlights <- sub("3", "rgba(255,0,255,1)", highlights)
    } else {
        highlights <- sub("0", "black", highlights)
        highlights <- sub("1", "blue", highlights)
        highlights <- sub("2", "red", highlights)
        highlights <- sub("3", "purple", highlights)
    }

    return(highlights)
}


.pV_seed_ggplot_annoTrack <- function(
    plotViewStart, plotViewEnd, view_chr,
    introns, exons, group.DT, condense_this, add_information
) {
    col_highlights <- sort(unique(introns$highlight))
    fill_highlights <- sort(unique(introns$highlight))
    col_highlights <- .pV_highlight_to_colors(col_highlights)
    fill_highlights <- .pV_highlight_to_colors(fill_highlights)

    if(add_information) {
        if (condense_this == TRUE) {
            anno <- data.frame(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.5 + 0.3 * 
                    runif(rep(1, nrow(group.DT))),
                Information = group.DT$display_name
            )
        } else {
            anno <- data.frame(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.4,
                Information = group.DT$display_name
            )
        }
    }
    if (nrow(group.DT) == 0) {
        max_plot_level <- 1
    } else {
        max_plot_level <- max(group.DT$plot_level)
    }
    
    p <- ggplot()
    
    if(nrow(introns) > 0) {
        p <- p + geom_line(data = introns,
            aes(x = get("start"), y = get("plot_level"),
            color = get("highlight"), group = get("Information"))
        )   
    }
    if(nrow(exons) > 0) {
        p <- p + geom_rect(data = exons,
            aes(xmin = get("start"), xmax = get("end"),
                ymin = get("plot_level") - 0.1 -
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                ymax = get("plot_level") + 0.1 +
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                fill = get("highlight")
            )
        )
    }

    p <- p + 
        scale_color_manual(values = col_highlights) +
        scale_fill_manual(values = fill_highlights)    
    
    p <- p + theme_white_legend_plot_track +
        theme(
            axis.text.y = element_blank(), 
            axis.title.y = element_blank(),
            legend.title = element_blank()
        )

    if(!is.null(anno)) {
        p <- p + geom_text(
            data = anno,
            aes(x = get("x"), y = get("y"), label = get("Information"))
        )
    }
    p <- p + theme(legend.position = "none") +
        labs(x = paste("Chromosome", view_chr))

    ref_ymin <- min(layer_scales(p)$y$range$range)
    ref_ymax <- max(layer_scales(p)$y$range$range)
    p <- p + 
        scale_x_continuous(labels = label_number(scale_cut = cut_si(""))) +
        coord_cartesian(
            xlim = c(plotViewStart, plotViewEnd),
            ylim = c(ref_ymin - 1, ref_ymax + 1),
            expand = FALSE
        )
    
    return(p)
}

.pV_seed_ggplotly_annoTrack <- function(
    plotViewStart, plotViewEnd, view_chr,
    introns, exons, group.DT, condense_this, add_information
) {
    
    col_highlights <- sort(unique(introns$highlight))
    fill_highlights <- sort(unique(introns$highlight))
    col_highlights <- .pV_highlight_to_colors(col_highlights)
    fill_highlights <- .pV_highlight_to_colors(fill_highlights)
    
    anno <- NULL
    if(add_information) {
        if (condense_this == TRUE) {
            anno <- list(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.5 + 0.3 * 
                    runif(rep(1, nrow(group.DT))),
                text = group.DT$display_name,
                xref = "x", yref = "y", showarrow = FALSE)
        } else {
            anno <- list(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.4,
                text = group.DT$display_name,
                xref = "x", yref = "y", showarrow = FALSE)
        }
    }
    if (nrow(group.DT) == 0) {
        max_plot_level <- 1
    } else {
        max_plot_level <- max(group.DT$plot_level)
    }
    
    p <- ggplot()
    
    if(nrow(introns) > 0) {
        p <- p + geom_line(data = introns,
            aes(x = get("start"), y = get("plot_level"),
            color = get("highlight"), group = get("Information"))
        )   
    }
    if(nrow(exons) > 0) {
        p <- p + geom_rect(data = exons,
            aes(xmin = get("start"), xmax = get("end"),
                ymin = get("plot_level") - 0.1 -
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                ymax = get("plot_level") + 0.1 +
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                fill = get("highlight")
            )
        )
    }

    p <- p + 
        scale_color_manual(values = col_highlights) +
        scale_fill_manual(values = fill_highlights)    
    
    p <- p + theme_white_legend_plot_track +
        theme(
            axis.text.y = element_blank(), 
            axis.title.y = element_blank(),
            legend.title = element_blank()
        )
    
    # ggplotly
    out_p <- ggplotly(p, tooltip = "text") %>%
        layout(
            annotations = anno, dragmode = "pan",
            xaxis = list(range = c(plotViewStart, plotViewEnd),
                title = paste("Chromosome/Scaffold", view_chr)),
            yaxis = list(range = c(0, 1 + max_plot_level),
                fixedrange = TRUE)
        )
            
    return(out_p)
}

.pV_seed_plotly_annoTrack <- function(
    plotViewStart, plotViewEnd, view_chr,
    introns, exons, group.DT, condense_this, add_information
) {
    
    col_highlights <- sort(unique(introns$highlight))
    fill_highlights <- sort(unique(exons$highlight))
    col_colors <- .pV_highlight_to_colors(col_highlights)
    fill_colors <- .pV_highlight_to_colors(fill_highlights)
    
    anno <- NULL
    if(add_information) {
        if (condense_this == TRUE) {
            anno <- data.frame(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.5 + 0.3 * 
                    runif(rep(1, nrow(group.DT))),
                Information = group.DT$display_name
            )
        } else {
            anno <- data.frame(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.4,
                Information = group.DT$display_name
            )
        }
    }
    if (nrow(group.DT) == 0) {
        max_plot_level <- 1
    } else {
        max_plot_level <- max(group.DT$plot_level)
    }
    
    fig <- plot_ly()
    
    if(nrow(introns) > 0) {
        intronLineData <- .plotly_makeLineData(
            introns$start, introns$plot_level, introns$end, introns$plot_level,
            introns$Information, introns$highlight
        )

        for(i in seq_len(length(col_highlights))) {
            hl <- col_highlights[i]
            color <- col_colors[i]
            
            fig <- fig %>% add_trace(
                data = intronLineData[intronLineData$colorInfo == hl,],
                x = as.formula("~x"),
                y = as.formula("~y"),
                text = as.formula("~text"),
                hoveron = "points", hoverinfo = 'text',
                line = list(
                    color = color
                ),
                type = 'scatter', mode = 'lines',
                showlegend = FALSE
            )
        }
    }
    
    typeThick <- c("CDS", "start_codon", "stop_codon")
    if(nrow(exons) > 0) {
        exons_thin <- exons[!(exons$type %in% typeThick), ]
        exons_thick <- exons[exons$type %in% typeThick, ]
        exons_thin$ymin <- exons_thin$plot_level - 0.15
        exons_thin$ymax <- exons_thin$plot_level + 0.15
        exons_thick$ymin <- exons_thick$plot_level - 0.3
        exons_thick$ymax <- exons_thick$plot_level + 0.3
        exons_comb <- rbind(exons_thin, exons_thick)

        exons_instr <- .plotly_makeRectData(
            exons_comb$start, exons_comb$end,
            exons_comb$ymin, exons_comb$ymax,
            exons_comb$Information,
            exons_comb$highlight,
            resolution = 10
        )        

        for(i in seq_len(length(fill_highlights))) {
            rects <- exons_instr[
                exons_instr$colorInfo == fill_highlights[i],
            ]

            fig <- fig %>% add_trace(
                    data = rects,
                    x = as.formula("~x"),
                    y = as.formula("~y"),
                    text = as.formula("~text"),
                    type = 'scatter', mode = 'lines',
                    hoveron = "points+fills", hoverinfo = 'text',
                    line = list(
                        color = "transparent"
                    ),
                    fill = "toself",
                    fillcolor = fill_colors[i],
                    
                    showlegend = FALSE
                )
        }
    }
    
    if(add_information) {
        xtitle <- paste("Chromosome/Scaffold", view_chr)
        fig <- fig %>% add_trace(
            data = anno,
            x = as.formula("~x"),
            y = as.formula("~y"),
            text = as.formula("~Information"),
            hoverinfo = 'text',
            type = 'scatter', mode = 'text',
            textposition = 'middle',
            showlegend = FALSE
        )
    } else {
        xtitle <- ""
    }
    
    fig <- fig %>% layout(
        dragmode = "pan",
        xaxis = list(
            range = c(plotViewStart, plotViewEnd),
            title = xtitle
        ),
        yaxis = list(
            title = "",
            range = c(0, 1 + max_plot_level),
            fixedrange = TRUE
        )
    )

    return(fig)
}

.pV_seed_fastplotly_annoTrack <- function(
    plotViewStart, plotViewEnd, view_chr,
    introns, exons, group.DT, condense_this, add_information
) {
    dataList <- list()
    dataCount <- 0

    spoof_df <- data.frame(x = 1, y = 1, text = "a")
    
    col_highlights <- sort(unique(introns$highlight))
    fill_highlights <- sort(unique(exons$highlight))
    col_colors <- .pV_highlight_to_colors(col_highlights)
    fill_colors <- .pV_highlight_to_colors(fill_highlights)
    
    anno <- NULL
    if(add_information) {
        if (condense_this == TRUE) {
            anno <- data.frame(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.5 + 0.3 * 
                    runif(rep(1, nrow(group.DT))),
                Information = group.DT$display_name
            )
        } else {
            anno <- data.frame(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.4,
                Information = group.DT$display_name
            )
        }
    }
    if (nrow(group.DT) == 0) {
        max_plot_level <- 1
    } else {
        max_plot_level <- max(group.DT$plot_level)
    }
    
    fig <- plot_ly()
    
    if(nrow(introns) > 0) {
        intronLineData <- .plotly_makeLineData(
            introns$start, introns$plot_level, introns$end, introns$plot_level,
            introns$Information, introns$highlight
        )

        for(i in seq_len(length(col_highlights))) {
            hl <- col_highlights[i]
            color <- col_colors[i]
            data_df <- intronLineData[intronLineData$colorInfo == hl,]

            dataCount <- dataCount + 1
            dataList[[dataCount]] <- .plotly_store_info(
                x = data_df$x, y = data_df$y, text = data_df$text
            )

            fig <- fig %>% add_trace(
                data = spoof_df,
                x = as.formula("~x"),
                y = as.formula("~y"),
                text = as.formula("~text"),
                hoveron = "points", hoverinfo = 'text',
                line = list(color = color, width = 1), # NB intron line width
                type = 'scatter', mode = 'lines',
                showlegend = FALSE
            )
        }
    }
    
    typeThick <- c("CDS", "start_codon", "stop_codon")
    if(nrow(exons) > 0) {
        exons_thin <- exons[!(exons$type %in% typeThick), ]
        exons_thick <- exons[exons$type %in% typeThick, ]
        exons_thin$ymin <- exons_thin$plot_level - 0.15
        exons_thin$ymax <- exons_thin$plot_level + 0.15
        exons_thick$ymin <- exons_thick$plot_level - 0.3
        exons_thick$ymax <- exons_thick$plot_level + 0.3
        exons_comb <- rbind(exons_thin, exons_thick)

        exons_instr <- .plotly_makeRectData(
            exons_comb$start, exons_comb$end,
            exons_comb$ymin, exons_comb$ymax,
            exons_comb$Information,
            exons_comb$highlight,
            resolution = 10
        )        

        for(i in seq_len(length(fill_highlights))) {
            rects <- exons_instr[
                exons_instr$colorInfo == fill_highlights[i],
            ]

            dataCount <- dataCount + 1
            dataList[[dataCount]] <- .plotly_store_info(
                x = rects$x, y = rects$y, text = rects$text
            )

            fig <- fig %>% add_trace(
                data = spoof_df,
                x = as.formula("~x"),
                y = as.formula("~y"),
                text = as.formula("~text"),
                hoveron = "points+fills", hoverinfo = 'text',
                line = list(color = "transparent"),
                type = 'scatter', mode = 'lines',
                fill = "toself",
                fillcolor = fill_colors[i],
                showlegend = FALSE
            )
        }
    }
    
    if(add_information) {
        xtitle <- paste("Chromosome/Scaffold", view_chr)

        dataCount <- dataCount + 1
        dataList[[dataCount]] <- .plotly_store_info(
            x = anno$x, y = anno$y, text = anno$Information
        )

        fig <- fig %>% add_trace(
            data = spoof_df,
            x = as.formula("~x"),
            y = as.formula("~y"),
            text = as.formula("~text"),
            hoverinfo = 'text',
            type = 'scatter', mode = 'text',
            textposition = 'middle',
            showlegend = FALSE
        )
    } else {
        xtitle <- ""
    }
    
    fig <- fig %>% layout(
        dragmode = "pan",
        xaxis = list(
            range = c(plotViewStart, plotViewEnd),
            title = xtitle
        ),
        yaxis = list(
            title = "",
            range = c(0, 1 + max_plot_level),
            fixedrange = TRUE
        )
    )
    fig <- fig

    return(list(
        plot = fig,
        data = dataList
    ))
}

.pV_seed_fastplotly2_annoTrack <- function(
    plotViewStart, plotViewEnd, view_chr,
    introns, exons, group.DT, condense_this, add_information
) {
    dataList <- list()

    # x,y axis range, title
    layoutList <- list()
       
    col_highlights <- fill_highlights <- c("0", "1", "2", "3")
     
    if(nrow(introns) > 0) {
        intronLineData <- .plotly_makeLineData(
            introns$start, introns$plot_level, introns$end, introns$plot_level,
            introns$Information, introns$highlight
        )

        for(i in seq_len(length(col_highlights))) {
            dataList[[i]] <- list()
            hl <- col_highlights[i]
            data_df <- intronLineData[intronLineData$colorInfo == hl,]
            if(nrow(data_df) > 0) {
                dataList[[i]] <- .plotly_store_info(
                    x = data_df$x, y = data_df$y, text = data_df$text
                )
            }
        }
    }
    
    typeThick <- c("CDS", "start_codon", "stop_codon")
    if(nrow(exons) > 0) {
        exons_thin <- exons[!(exons$type %in% typeThick), ]
        exons_thick <- exons[exons$type %in% typeThick, ]
        exons_thin$ymin <- exons_thin$plot_level - 0.15
        exons_thin$ymax <- exons_thin$plot_level + 0.15
        exons_thick$ymin <- exons_thick$plot_level - 0.3
        exons_thick$ymax <- exons_thick$plot_level + 0.3
        exons_comb <- rbind(exons_thin, exons_thick)

        exons_instr <- .plotly_makeRectData(
            exons_comb$start, exons_comb$end,
            exons_comb$ymin, exons_comb$ymax,
            exons_comb$Information,
            exons_comb$highlight,
            resolution = 10
        )        

        for(i in seq_len(length(fill_highlights))) {
            rects <- exons_instr[
                exons_instr$colorInfo == fill_highlights[i],
            ]

            if(nrow(rects) > 0) {
                dataList[[i + 4]] <- .plotly_store_info(
                    x = rects$x, y = rects$y, text = rects$text
                )
            }
        }
    }

    if(add_information) {
        if (condense_this == TRUE) {
            dataList[[9]] <- list(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.5 + 0.3 * 
                    runif(rep(1, nrow(group.DT))),
                text = group.DT$display_name
            )
        } else {
            dataList[[9]] <- list(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.4,
                text = group.DT$display_name
            )
        }
    } else {
        dataList[[9]] <- list()
    }
    
    if(add_information) {
        xtitle <- paste("Chromosome/Scaffold", view_chr)
    } else {
        xtitle <- ""
    }

    if (nrow(group.DT) == 0) {
        max_plot_level <- 1
    } else {
        max_plot_level <- max(group.DT$plot_level)
    }
    layoutList <- list(
        xrange = c(plotViewStart, plotViewEnd),
        xtitle = xtitle,
        yrange = c(0, 1 + max_plot_level)
    )

    return(list(
        dataList = dataList,
        layoutList = layoutList
    ))
}

################################################################################

.seq2 <- Vectorize(seq.default, vectorize.args = c("from", "to", "length.out"))

.cPO_jn_arcs <- function(
        junc, 
        arcHeight = 0,
        junctionThreshold = 0
) {
    if(is.null(junc)) return(NA)
    
    DT <- data.table(
        juncName = paste0(
            seqnames(junc), ":",
            start(junc), "-", end(junc), "/", strand(junc)
        ),
        leftX = start(junc) - 1,
        rightX = end(junc) + 1,
        leftY = mcols(junc)$leftCoordHeight,
        rightY = mcols(junc)$rightCoordHeight
    )
    isMean <- ("mean" %in% names(mcols(junc)))
    if(isMean) {
        DT$count <- mcols(junc)$mean
        DT$countsd <- mcols(junc)$sd
        DT$value <- paste0(
            round(100 * DT$count, 1), "+/-", 
            round(100 * DT$countsd, 1), " %"
        )
        DT$info <- paste(
            paste0("Junction: ", DT$juncName),
            paste0("PSI: ", DT$value),
            sep = "\n"
        )
    } else {
        DT$count <- mcols(junc)$count
        DT$countsd <- 0
        DT$value <- round(DT$count,2)
        DT$info <- paste(
            paste0("Junction: ", DT$juncName),
            paste0("Depth: ", DT$count),
            sep = "\n"
        )
    }
    
    DT <- DT[get("count") >= junctionThreshold]
    
    # final_list <- list()
    # for(i in seq_len(nrow(DT))) {
        # row <- DT[i]
        
        # outDT <- data.table(
            # coord = row$juncName,
            # value = row$value,
            # info = row$info,
            # x = seq(row$leftX, row$rightX, length.out = 90),
            # y = seq(row$leftY, row$rightY, length.out = 90)
        # )
        # outDT[, c("yarc") := 
            # get("y") + sinpi(seq(0,1,length.out = 90)) * arcHeight
        # ]
        # final_list[[i]] <- outDT
    # }
    # return(rbindlist(final_list))

    final_DT <- data.table(
        coord = rep(DT$juncName, each = 90),
        value = rep(DT$value, each = 90),
        info = rep(DT$info, each = 90),
        x = as.vector(.seq2(DT$leftX, DT$rightX, length.out = 90)),
        ytmp = as.vector(.seq2(DT$leftY, DT$rightY, length.out = 90)),
        yarc = as.vector(.seq2(DT$leftY, DT$rightY, length.out = 90)) +
            rep(arcHeight * sinpi(seq(0,1,length.out = 90)), nrow(DT))
    )
    return(final_DT)
}



################################################################################

.gPO_check_tracks <- function(
    obj, args
) {

    # sanity check condition / tracks against colData
    colData <- obj@colData
    sampleList <- list()
    samples_to_check <- c()
    
    # tracks must be a character vector
    if(!is.vector(args[["tracks"]], "character")) {
        .log(paste(
            "In getPlotObject,",
            "`tracks` must be a character vector"            
        ))
    }
    
    # remove invalid tracks
    invalid_tracks <- c()
    if("condition" %in% names(args)) {
        if(args[["condition"]] %in% colnames(colData)) {
            for(cond_elem in args[["tracks"]]) {
                # cond_elem is of length 1
                if(
                    any(colData[, args[["condition"]]] == cond_elem)
                ) {
                    sampleList[[cond_elem]] <- rownames(colData)[
                        colData[, args[["condition"]]] == cond_elem]
                    samples_to_check <- c(samples_to_check,
                        sampleList[[cond_elem]])
                } else {
                    # ignore track altogether
                    invalid_tracks <- c(invalid_tracks, cond_elem)
                }
            }
        } else {
            .log(paste("In getPlotObject,",
                "condition is not a recognised column in colData"
            ))
        }
    } else {
        for(i in seq_len(length(args[["tracks"]]))) {
            for(samp in args[["tracks"]]) {
                if(samp %in% rownames(colData)) {
                    sampleList[[samp]] <- samp
                    samples_to_check <- c(samples_to_check, samp)
                } else {
                    invalid_tracks <- c(invalid_tracks, samp)
                }
            }
        }
    }
    
    # Remove invalid tracks
    if(length(invalid_tracks) == length(args[["tracks"]])) {
        .log(paste(
            "In getPlotObject,",
            "all elements in `tracks` are invalid"    
        ))
    } else if(length(invalid_tracks) > 0) {
        args[["tracks"]] <- args[["tracks"]][
            !(args[["tracks"]] %in% invalid_tracks)
        ]
    }
    
    args[["sampleList"]] <- sampleList
    args[["samples_to_check"]] <- samples_to_check
    
    return(args)
}

.gPO_check_strand <- function(
    obj, args
) {
    args[["view_strand_jn"]] <- args[["strand"]]
    samples_to_check <- args[["samples_to_check"]]
    if(args[["strand"]] != "*") {
        if(all(obj@normData[["sampleStrand"]][samples_to_check] == -1)) {
            if(args[["strand"]] == "+") {
                args[["view_strand"]] <- "-"
            } else {
                args[["view_strand"]] <- "+"
            }
        }
    } else {
        args[["view_strand"]] <- "*"
    }
    return(args)
}

################################################################################

# Get normalized coverage from obj
.gCD_getCoverage <- function(obj, args, normalize = FALSE) {
    view_start <- args[["limit_start"]]
    view_end <- args[["limit_end"]]
    view_strand <- args[["view_strand"]]
    Event <- args[["Event"]]
    
    outList <- list()
    sampleList <- args[["sampleList"]]
    
    if(view_strand == "+") {
        cov <- obj@covData$pos
    } else if(view_strand == "-") {
        cov <- obj@covData$neg    
    } else {
        cov <- obj@covData$uns    
    }
    
    for(i in seq_len(length(sampleList))) {
        track <- names(sampleList)[i]
        samples <- sampleList[[i]]
        
        matList <- list()
        for(s in samples) {
            view <- IRanges::Views(cov[[s]], view_start, view_end)
            matList[[s]] <- as.matrix(view[[1]])
        }
        mat <- do.call(cbind, matList)
        colnames(mat) <- samples
        
        # Normalize coverage
        if(normalize) {
            normFactor <- unlist(obj@normData$norms[Event,samples])
            
            # discard samples with low normalization factors
            which_lowNorm <- which(normFactor < 5)
            
            if(length(which_lowNorm) == length(normFactor)) {
                outList[[track]] <- data.frame(x = seq(view_start, view_end))
                next
            } else if(length(which_lowNorm) > 0) {
                which_Norm <- which(normFactor > 5)
                mat <- mat[, which_Norm, drop = FALSE]
                normFactor <- normFactor[which_Norm]
            }
            
            mat <- t(t(mat) / normFactor)
        }
        
        outList[[track]] <- data.table(x = seq(view_start, view_end))
        outList[[track]] <- cbind(outList[[track]], as.data.table(mat))
        if(length(samples) == 1) {
            colnames(outList[[track]])[2] <- "depth"
        }
    }
    return(outList)
}

.gCD_binCoverage <- function(cov, divFactor, junc) {
    out <- list()
    outnames <- names(cov)
    
    juncSpares <- c()
    for(i in seq_len(length(junc))) {
        juncSpares <- c(
            juncSpares,
            start(junc[[i]]) - 1,
            end(junc[[i]]) + 1
        )
    }
    juncSpares <- sort(unique(juncSpares))
    
    for(i in seq_len(length(cov))) {
        out[[outnames[i]]] <- .gCD_bin_df(
            cov[[outnames[i]]], 
            divFactor, juncSpares
        )
    }
    return(out)
}

.gCD_bin_df <- function(df, binwidth = 3, spareCoords = c()) {
    DT <- as.data.table(df)
    brks <- seq(1, 
        nrow(DT) + 1, 
        length.out = (nrow(DT) + 1) / binwidth
    )
    if(length(spareCoords) > 0) {
        brks <- c(brks, which(DT$x %in% spareCoords))
    }
    brks <- sort(unique(brks))
    
    bin <- NULL
    DT[, c("bin") := findInterval(seq_len(nrow(DT)), brks)]
    DT2 <- DT[, lapply(.SD, mean, na.rm = TRUE), by = "bin"]
    DT2[, c("bin") := NULL]
    return(as.data.frame(DT2))
}

.gCD_covStats <- function(cov) {
    out <- list()
    outnames <- names(cov)
    conf.int <- 0.95
    
    for(i in seq_len(length(cov))) {
        covmat <- as.matrix(cov[[outnames[i]]][,-1])
        out[[outnames[i]]] <- data.table(
            x = cov[[outnames[i]]]$x,
            mean = rowMeans(covmat)
        )
        n <- ncol(covmat)
        
        out[[outnames[i]]]$sd <- rowSds(covmat)
        out[[outnames[i]]]$sem <- out[[outnames[i]]]$sd / sqrt(n)
        out[[outnames[i]]]$ci <- qt((1 + conf.int) / 2, df = n - 1) * 
            out[[outnames[i]]]$sem
    }
    return(out)
}

.gCD_ttest <- function(cov1, cov2) {
    coords <- sort(intersect(cov1$x, cov2$x))
    mat <- cbind(
        as.matrix(cov1[get("x") %in% coords, -1]),
        as.matrix(cov2[get("x") %in% coords, -1])
    )
    fac <- factor(
        c(
            rep("1", ncol(cov1) - 1),
            rep("2", ncol(cov2) - 1)       
        )
    )
    
    t_test <- genefilter::rowttests(mat, fac)
    
    ret <- data.frame(
        x = coords,
        stat = -log10(t_test$p.value)
    )
    ret$stat[!is.finite(ret$stat)] <- 0
    return(ret)
}

.gCD_getPSI <- function(obj, args, norm_cov) {
    view_chr <- args[["view_chr"]]
    view_start <- args[["limit_start"]]
    view_end <- args[["limit_end"]]
    view_strand_jn <- args[["view_strand_jn"]]

    outList <- list()
    sampleList <- args[["sampleList"]]

    gr_select <- GRanges(
        view_chr, 
        IRanges(view_start, view_end), 
        view_strand_jn
    )
    OL <- findOverlaps(obj@juncData$junc_gr, gr_select)
        
    if(length(unique(from(OL))) == 0) return(list())

    hits <- sort(unique(from(OL)))
    junc_gr <- obj@juncData$junc_gr[hits]
    leftCoords <- start(junc_gr) - 1
    rightCoords <- end(junc_gr) + 1
    lC_inrange <- leftCoords >= view_start & leftCoords <= view_end
    rC_inrange <- rightCoords >= view_start & rightCoords <= view_end

    # normalize by starting coordinates:

    for(i in seq_len(length(sampleList))) {
        track <- names(sampleList)[i]
        samples <- sampleList[[i]]
        
        junc <- obj@juncData$junc_PSI[hits, samples, drop = FALSE]
        
        # Returned data
        outList[[track]] <- .grDT(cbind(
            as.data.frame(junc_gr),
            data.frame(
                mean = rowMeans(junc),
                sd = rowSds(junc),
                leftCoordHeight = 1,
                rightCoordHeight = 1
            )
        ), keep.extra.columns = TRUE)
        
        cov <- norm_cov[[track]]
        
        if(sum(lC_inrange) > 0) {
            covL <- cov[leftCoords[lC_inrange] - cov$x[1] + 1, -1]
            mcols(outList[[track]])$leftCoordHeight[lC_inrange] <- rowMeans(covL)
        }
            
        if(sum(rC_inrange) > 0) {
            covR <- cov[rightCoords[rC_inrange] - cov$x[1] + 1, -1]
            mcols(outList[[track]])$rightCoordHeight[rC_inrange] <- rowMeans(covR)
        }
    }
    return(outList)
}

.gCD_getJunc <- function(obj, args, raw_cov, normalized = FALSE) {
    view_chr <- args[["view_chr"]]
    view_start <- args[["limit_start"]]
    view_end <- args[["limit_end"]]
    view_strand_jn <- args[["view_strand_jn"]]

    outList <- list()
    sampleList <- args[["sampleList"]]

    gr_select <- GRanges(
        view_chr, 
        IRanges(view_start, view_end), 
        view_strand_jn
    )
    OL <- findOverlaps(obj@juncData$junc_gr, gr_select)
        
    if(length(unique(from(OL))) == 0) return(list())

    hits <- sort(unique(from(OL)))
    junc_gr <- obj@juncData$junc_gr[hits]
    leftCoords <- start(junc_gr) - 1
    rightCoords <- end(junc_gr) + 1
    lC_inrange <- leftCoords >= view_start & leftCoords <= view_end
    rC_inrange <- rightCoords >= view_start & rightCoords <= view_end

    Event <- NULL
    if(normalized) Event <- args[["Event"]]
    for(i in seq_len(length(sampleList))) {
        track <- names(sampleList)[i]
        samples <- sampleList[[i]]
        
        # Only do it if cov is a single track
        if(length(samples) == 1) {
            if(view_strand_jn == "*") {
                junc <- obj@juncData$junc_counts_uns[hits, samples, drop = FALSE]
            } else {
                junc <- obj@juncData$junc_counts[hits, samples, drop = FALSE]            
            }
          
            cov <- raw_cov[[track]]
            
            # Normalize
            if(normalized) {
                normFactor <- unlist(obj@normData$norms[Event,samples])
                junc <- junc / normFactor
            }
          
            # Returned data
            outList[[track]] <- .grDT(cbind(
                as.data.frame(junc_gr),
                data.frame(
                    count = unname(unlist(junc)),
                    leftCoordHeight = max(cov[,2]),
                    rightCoordHeight = max(cov[,2])
                )
            ), keep.extra.columns = TRUE)

            if(sum(lC_inrange) > 0) {
                covL <- unname(unlist(
                    cov[leftCoords[lC_inrange] - cov$x[1] + 1, -1]
                ))
                mcols(outList[[track]])$leftCoordHeight[lC_inrange] <- covL
            }
            if(sum(rC_inrange) > 0) {
                covR <- unname(unlist(
                    cov[rightCoords[rC_inrange] - cov$x[1] + 1, -1]
                ))
                mcols(outList[[track]])$rightCoordHeight[rC_inrange] <- covR
            }
        } else {
            # empty
            outList[[track]] <- GRanges()
        }

    }
    return(outList)
}

# list checker for plotViews

.pV_trackList_from_vector <- function(trackVec, args) {
    trackList <- list()
    
    if(is.vector(trackVec, "numeric")) {
        idx <- trackVec
        if(all(idx %in% seq_len(length(args[["tracks"]])))) {
            trackList <- lapply(idx, function(i) i)
        } else if(any(idx %in% seq_len(length(args[["tracks"]])))) {
            idx <- idx[idx %in% seq_len(length(args[["tracks"]]))]
            trackList <- lapply(idx, function(i) i)
        } else {
            .log(paste(
                "In plotView,",
                "`trackList` contains indices outside the range of tracks",
                "found in tracks(covPlotObject)"
            ))
        }
    } else if(is.vector(trackVec, "character")) {
        idxNames <- trackVec
        if(all(idxNames %in% args[["tracks"]])) {
            trackList <- lapply(idxNames, function(i) {
                which(args[["tracks"]] == i)[1]
            })
        } else if(any(idxNames %in% args[["tracks"]])) {
            idxNames <- idxNames[idxNames %in% args[["tracks"]]]
            trackList <- lapply(idxNames, function(i) {
                which(args[["tracks"]] == i)[1]
            })
        } else {
            .log(paste(
                "In plotView,",
                "`trackList` contains tracks",
                "not found in tracks(covPlotObject)"
            ))
        }
    }
    
    if(!is.null(names(trackVec))) {
        names(trackList) <- names(trackVec)
        if(any(names(trackList) == "")) {
            which_noname <- which(names(trackList) == "")
            names(trackList)[which_noname] <- paste(
                "Track", as.character(which_noname), sep = "_"
            )
        }
    } else {
        for(i in seq_len(length(trackList))) {
            elem <- trackList[[i]]
            elemNames <- args[["tracks"]][elem]
            names(trackList)[i] <- paste(elemNames, collapse = ",")
        }
    }
    
    return(trackList)
}

.pV_trackList_from_list <- function(trackList, args) {
    outList <- list()
    for(z in seq_len(length(trackList))) {
        trackVec <- trackList[[z]]
        
        if(is.vector(trackVec, "numeric")) {
            idx <- trackVec
            if(all(idx %in% seq_len(length(args[["tracks"]])))) {
                outList[[z]] <- idx
            } else if(any(idx %in% seq_len(length(args[["tracks"]])))) {
                idx <- idx[idx %in% seq_len(length(args[["tracks"]]))]
                outList[[z]] <- idx
            } else {
                .log(paste(
                    "In plotView,",
                    "`trackList` contains indices outside the range of tracks",
                    "found in tracks(covPlotObject)"
                ))
            }
        } else if(is.vector(trackVec, "character")) {
            idxNames <- trackVec
            if(all(idxNames %in% args[["tracks"]])) {
                outList[[z]] <- which(args[["tracks"]] %in% idxNames)
            } else if(any(idxNames %in% args[["tracks"]])) {
                idxNames <- idxNames[idxNames %in% args[["tracks"]]]
                outList[[z]] <- which(args[["tracks"]] %in% idxNames)
            } else {
                .log(paste(
                    "In plotView,",
                    "`trackList` contains tracks",
                    "not found in tracks(covPlotObject)"
                ))
            }
        }
    }
    
    # transfer names
    if(!is.null(names(trackList))) {
        names(outList) <- names(trackList)
        if(any(names(outList) == "")) {
            which_noname <- which(names(outList) == "")
            names(outList)[which_noname] <- paste(
                "Track", as.character(which_noname), sep = "_"
            )
        }
    } else {
        for(i in seq_len(length(outList))) {
            elem <- outList[[i]]
            elemNames <- args[["tracks"]][elem]
            names(outList)[i] <- paste(elemNames, collapse = ",")
        }
    }
    
    return(outList)
}

.plotly_makeJuncCurveData <- function(
    x, yarc, info
) {
    sourceDT <- data.table(
        x = x, y = yarc, info = info
    )
    setorderv(c("info", "x"))
    infoVec <- unique(sourceDT$info)

    df_list <- list()
    for(i in seq_len(length(infoVec))) {
        subDT <- sourceDT[get("info") == infoVec[i]]
        df_list[[2 * i - 1]] <- data.table(
            x = subDT$x,
            y = subDT$y,
            text = infoVec[i]
        )
        if(i < length(info)) {
            df_list[[2 * i]] <- data.table(
                x = NA, y = NA, text = NA
            )
        }
    }
    return(as.data.frame(rbindlist(df_list)))
}

.plotly_makeLineData <- function(
    xstart, ystart, xend, yend, info, colorInfo, resolution = 20
) {
    df_list <- list()
    for(i in seq_len(length(info))) {
        df_list[[2 * i - 1]] <- data.table(
            x = seq(xstart[i], xend[i], length.out = resolution),
            y = seq(ystart[i], yend[i], length.out = resolution),
            text = info[i],
            colorInfo = colorInfo[i]
        )
        if(i < length(info)) {
            df_list[[2 * i]] <- data.table(
                x = NA, y = NA, text = NA, colorInfo = colorInfo[i]
            )
        }
    }
    return(as.data.frame(rbindlist(df_list)))
}

.plotly_makeRectData <- function(
    xmin, xmax, ymin, ymax, info, colorInfo, resolution = 20
) {
    df_list <- list()
    if(resolution < 1) resolution <- 1
    for(i in seq_len(length(info))) {
        df_list[[5 * i - 4]] <- data.table(
            x = seq(xmin[i], xmax[i], length.out = resolution + 1)[-1],
            y = ymin[i],
            text = info[i],
            colorInfo = colorInfo[i]
        )
        df_list[[5 * i - 3]] <- data.table(
            x = xmax[i],
            y = seq(ymin[i], ymax[i], length.out = resolution + 1)[-1],
            text = info[i],
            colorInfo = colorInfo[i]
        )
        df_list[[5 * i - 2]] <- data.table(
            x = seq(xmax[i], xmin[i], length.out = resolution + 1)[-1],
            y = ymax[i],
            text = info[i],
            colorInfo = colorInfo[i]
        )
        df_list[[5 * i - 1]] <- data.table(
            x = xmin[i],
            y = seq(ymax[i], ymin[i], length.out = resolution + 1),
            text = info[i],
            colorInfo = colorInfo[i]
        )
        if(i < length(info)) {
            df_list[[5 * i]] <- data.table(
                x = NA, y = NA, text = NA, colorInfo = colorInfo[i]
            )
        }
    }
    return(as.data.frame(rbindlist(df_list)))
}

.pV_assemble_plotly <- function(
    covTrack, diffTrack, annoFullTrack, verticalLayout
) {
    vLnorm <- verticalLayout / sum(verticalLayout)

    if(length(covTrack) == 0) covTrack[[1]] <- list()
    if(length(diffTrack) == 0) diffTrack[[1]] <- list()

    inputList <- list(
        covTrack = covTrack[[1]],
        diffTrack = diffTrack[[1]],
        annoFullTrack = annoFullTrack
    )
    doPlot <- c(
        length(covTrack[[1]]) > 0, 
        length(diffTrack[[1]]) > 0, 
        length(annoFullTrack) > 0
    )
    if(sum(doPlot) == 0) return(NULL)

    nPlot <- c(length(covTrack[[1]]), length(diffTrack[[1]]), length(annoFullTrack))
    nPlot <- nPlot[nPlot > 0]

    vLnorm_final <- c()
    for(i in seq_len(length(nPlot))) {
        vLnorm_final <- c(vLnorm_final, rep(vLnorm[i] / nPlot[i], nPlot[i]))
    }
    
    # simple plot - don't muck around
    finalList <- list()
    listCount <- 0
    for(l in inputList) {
        if(length(l) > 0) {
            for(e in l) {
                listCount <- listCount + 1
                finalList[[listCount]] <- e
            }
        }
    }
    
    suppressWarnings({
        finalPlot <- subplot(
            finalList, nrows = sum(nPlot), 
            shareX = TRUE, titleY = TRUE,
            heights = vLnorm_final
        )
    })
    
    if(length(annoFullTrack) == 1) {
        fullAnnoPlotNumber <- length(annoFullTrack[[1]]$x$data)
        if(fullAnnoPlotNumber > 1) {
            for(i in seq(
                length(finalPlot$x$data) + 1 - fullAnnoPlotNumber, 
                length(finalPlot$x$data)
            )) {
                finalPlot$x$data[[i]]$showlegend <- FALSE
            }        
        }
    }

    return(finalPlot)
}

.pV_assemble_fastplotly <- function(
    covTrack, diffTrack, annoFullTrack, verticalLayout
) {
    vLnorm <- verticalLayout / sum(verticalLayout)

    inputList <- list(
        covTrack = covTrack,
        diffTrack = diffTrack,
        annoFullTrack = annoFullTrack
    )
    doPlot <- c(
        length(covTrack) > 0, 
        length(diffTrack) > 0, 
        length(annoFullTrack) > 0
    )
    if(sum(doPlot) == 0 | sum(doPlot) != length(vLnorm)) return(NULL)
    inputList <- inputList[doPlot]
    finalList <- lapply(inputList, function(x) x[[1]][["plot"]])
    
    finalPlot <- subplot(
        finalList, nrows = length(vLnorm), 
        shareX = TRUE, titleY = TRUE,
        heights = vLnorm
    )
    
    # combine data here
    dataList <- list()
    dataCount <- 0
    for(plotElem in inputList) {
        plotData <- plotElem[[1]][["data"]]
        for(j in seq_len(length(plotData))) {
            dataCount <- dataCount + 1
            if(!is.null(plotData[[j]])) {
                finalPlot$x$data[[dataCount]]$x <- plotData[[j]]$x
                finalPlot$x$data[[dataCount]]$y <- plotData[[j]]$y
                finalPlot$x$data[[dataCount]]$text <- plotData[[j]]$text
            }
        }
    }
    
    return(finalPlot)
}

.pV_assemble_covPlotly <- function(p) {
    vLnorm <- p@vLayout / sum(p@vLayout)

    inputList <- list(
        covTrack = p@covTrack,
        diffTrack = p@diffTrack,
        annoFullTrack = p@annoTrack
    )
    doPlot <- c(
        length(p@covTrack) > 0, 
        length(p@diffTrack) > 0, 
        length(p@annoTrack) > 0
    )
    if(sum(doPlot) == 0 | sum(doPlot) != length(vLnorm)) return(NULL)
    inputList <- inputList[doPlot]
    
    finalList <- list()
    flCount <- 0
    realvLnorm <- c()
    for(i in seq_len(length(inputList))) {
        realvLnorm <- c(realvLnorm, 
            rep(vLnorm[i] / length(inputList[[i]]), length(inputList[[i]]) )
        )
        for(j in seq_len(length(inputList[[i]]))) {
            flCount <- flCount + 1
            finalList[[flCount]] <- inputList[[i]][[j]][["plot"]]
        }
    }
    
    finalPlot <- subplot(
        finalList, nrows = length(realvLnorm), 
        shareX = TRUE, titleY = TRUE,
        heights = realvLnorm
    )
    
    # combine data here
    dataList <- list()
    dataCount <- 0

    for(i in seq_len(length(inputList))) {
        for(j in seq_len(length(inputList[[i]]))) {
            plotData <- inputList[[i]][[j]][["data"]]
            for(k in seq_len(length(plotData))) {
                if(!is.null(plotData[[k]])) {
                    dataCount <- dataCount + 1
                    finalPlot$x$data[[dataCount]]$x <- plotData[[k]]$x
                    finalPlot$x$data[[dataCount]]$y <- plotData[[k]]$y
                    finalPlot$x$data[[dataCount]]$text <- plotData[[k]]$text
                }
            }
        }
    }

    p@fig[[1]] <- finalPlot
    return(p)
}

.pV_assemble_covPlotly2 <- function(p, vLayout) {
    numCovTraces <- numDiffTraces <- c()
    if(length(p@covTrack) > 0) {
        numCovTraces <- vapply(p@covTrack[[1]][["dataList"]], length, 0)
        numCovTraces <- (numCovTraces - 2)/2
    }
    if(length(p@diffTrack) > 0) {
        numDiffTraces <- vapply(p@diffTrack[[1]][["dataList"]], length, 0)
    }    
    p <- knitPlotly(p, numCovTraces, numDiffTraces, vLayout)

    # inject plot data
    for(i in seq_len(length(numCovTraces))) {
        p <- injectPlotData(p, p@args[["covTrackPos"]][i], 
            p@covTrack[[1]][["dataList"]][[i]],
            p@covTrack[[1]][["layoutList"]][[i]][["title"]]
        )
    }
    for(i in seq_len(length(numDiffTraces))) {
        p <- injectPlotData(p, p@args[["diffTrackPos"]][i], 
            p@diffTrack[[1]][["dataList"]][[i]],
            p@diffTrack[[1]][["layoutList"]][[i]][["title"]]
        )
    }

    p <- injectPlotData(p, p@args[["annoTrackPos"]], 
        p@annoTrack[[1]][["dataList"]],
        p@annoTrack[[1]][["layoutList"]][["xtitle"]]
    )

    # Layout modifications
    # x axis
    if("xtitle" %in% names(p@annoTrack[[1]][["layoutList"]])) {
        p <- adjustXtitle(p, p@annoTrack[[1]][["layoutList"]][["xtitle"]])
    }
    if("xrange" %in% names(p@annoTrack[[1]][["layoutList"]])) {
        p <- adjustXrange(p, p@annoTrack[[1]][["layoutList"]][["xrange"]])
    }

    # y axis
    axisNum <- 0
    for(i in seq_len(length(numCovTraces))) {
        axisNum <- axisNum + 1
        p <- fixYrange(p, axisNum)
        if("yrange" %in% names(p@covTrack[[1]][["layoutList"]][[i]])) {
            p <- adjustYrange(p, 
                p@covTrack[[1]][["layoutList"]][[i]][["yrange"]],
                axisNum
            )
        }
        if("title" %in% names(p@covTrack[[1]][["layoutList"]][[i]])) {
            p <- adjustYtitle(p, 
                p@covTrack[[1]][["layoutList"]][[i]][["title"]],
                axisNum
            )
        }
    }
    for(i in seq_len(length(numDiffTraces))) {
        axisNum <- axisNum + 1
        p <- fixYrange(p, axisNum)
        if("yrange" %in% names(p@diffTrack[[1]][["layoutList"]][[i]])) {
            p <- adjustYrange(p, 
                p@diffTrack[[1]][["layoutList"]][[i]][["yrange"]],
                axisNum
            )
        }
        if("title" %in% names(p@diffTrack[[1]][["layoutList"]][[i]])) {
            p <- adjustYtitle(p, 
                p@diffTrack[[1]][["layoutList"]][[i]][["title"]],
                axisNum
            )
        }
    }
    
    axisNum <- axisNum + 1
    p <- adjustYtitle(p, "", axisNum)
    if("yrange" %in% names(p@covTrack[["layoutList"]][[i]])) {
        p <- adjustYrange(p, p@covTrack[["layoutList"]][[i]][["yrange"]],
            axisNum)
    }

    return(p)
}


.pV_assemble_ggplot <- function(
    covTrack, diffTrack, annoSubTrack, annoFullTrack,
    verticalLayout, horizontalLayout
) {
    hCount <- length(horizontalLayout)
    vCount <- length(verticalLayout)
    
    bVec <- cumsum(verticalLayout)
    rVec <- cumsum(horizontalLayout)
    if(vCount > 1){
        tVec <- c(1, 1 + bVec[-vCount])
    } else {
        tVec <- 1
    }
    if(hCount > 1){
        lVec <- c(1, 1 + rVec[-hCount])
    } else {
        lVec <- 1
    }
    
    # Set up patchwork
    hasAnnoFT <- length(annoFullTrack) == 1
    
    for(v in seq_len(length(verticalLayout))) {
        if(v == vCount & hasAnnoFT) {
            layout_instr <- c(layout_instr, patchwork::area(
                t = tVec[v], b = bVec[v], l = 1, r = sum(horizontalLayout)
            ))
        }
        for(h in seq_len(length(horizontalLayout))) {
            if(v == 1 & h == 1) {
                # initialize
                layout_instr <- patchwork::area(
                    t = tVec[1], b = bVec[1], l = lVec[1], r = rVec[1]
                )
            } else {
                layout_instr <- c(layout_instr, patchwork::area(
                    t = tVec[v], b = bVec[v], 
                    l = lVec[h], r = rVec[h]
                ))
            }
            
        }
    }

    fullPlotList <- list()
    plotCount <- 0
    rowCount <- 0
    if(length(covTrack) > 0) {
        rowCount <- rowCount + 1
        for(i in seq_len(length(covTrack))) {
            plotCount <- plotCount + 1
            fullPlotList[[plotCount]] <- .pV_mod_ggplot(
                covTrack[[i]], rowCount, i, hCount, length(covTrack)
            )
        }
    }
    if(length(diffTrack) > 0) {
        rowCount <- rowCount + 1
        for(i in seq_len(length(diffTrack))) {
            plotCount <- plotCount + 1
            fullPlotList[[plotCount]] <- .pV_mod_ggplot(
                diffTrack[[i]], rowCount, i, hCount, length(diffTrack)
            )
        }
    }
    if(length(annoSubTrack) > 0) {
        rowCount <- rowCount + 1
        for(i in seq_len(length(annoSubTrack))) {
            plotCount <- plotCount + 1
            fullPlotList[[plotCount]] <- .pV_mod_ggplot(
                annoSubTrack[[i]], rowCount, i, hCount, length(annoSubTrack)
            )
        }
    } 
    if(hasAnnoFT) {
        plotCount <- plotCount + 1
        fullPlotList[[plotCount]] <- annoFullTrack[[1]]
    }

    return(
        patchwork::wrap_plots(fullPlotList) +
            patchwork::plot_layout(design = layout_instr)
    )
}

.pV_mod_ggplot <- function(p, x, y, maxX, maxY) {
    theme_nonright <- theme(
        legend.position = "none"
    )
    theme_nonleft <- theme(
        axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank()
    )
    theme_nonbottom <- theme(
        axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank()
    )

    if(x > 1) p <- p + theme_nonleft
    if(x < maxX) p <- p + theme_nonright
    if(y < maxY) p <- p + theme_nonbottom
    
    return(p)
}