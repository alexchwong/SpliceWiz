#' Function to retrieve / compile data for making coverage plots
#'
#' @param se  A \linkS4class{NxtSE} object, created by [makeSE].
#'   COV files must be linked to the NxtSE object. To do this, see the example
#'   in [makeSE]. Required by `plotCoverage`. Not required by `plotGenome` if
#'   `reference_path` is supplied.
#' @param reference_path The path of the reference generated by
#'   [Build-Reference-methods]. Required by `plotGenome` if a 
#'   \linkS4class{NxtSE} object is not specified.
#' @param Event The `EventName` of the IR / alternative splicing event to be
#'   displayed. Use `rownames(se)` to display a list of valid events.
#' @param Gene Whether to use the range for the given `Gene`. If given,
#'   overrides `Event` (but `Event` or `norm_event` will be used to normalise by
#'  condition). Valid `Gene` entries include gene_id (Ensembl ID) or gene_name
#'  (Gene Symbol).
#' @param seqname,start,end The chromosome (string) and genomic `start/end`
#'   coordinates (numeric) of the region to display. If present, overrides both
#'   `Event` and `Gene`. E.g. for a given region of chr1:10000-11000,
#'   use the parameters: `seqname = "chr1", start = 10000, end = 11000`
#' @param coordinates A string specifying genomic coordinates can be given
#'   instead of `seqname,start,end`. Must be of the format "chr:start-end", e.g.
#'   "chr1:10000-11000"
#' @param strand Whether to show coverage of both strands "*" (default), or
#'   from the "+" or "-" strand only.
#' @param zoom_factor Zoom out from event. Each level of zoom zooms out by a
#'   factor of 3. E.g. for a query region of chr1:10000-11000, if a
#'   `zoom_factor` of 1.0 is given, chr1:99000-12000 will be displayed.
#' @param tracks The names of individual samples,
#'   or the names of the different conditions to be plotted. For the latter, set
#'   `condition` to the specified condition category.
#' @param condition To display normalised coverage per condition, set this to
#'   the condition category. If omitted, `tracks` are assumed to refer to the
#'   names of individual samples.
#' @param norm_event Whether to normalise by an event different to that given
#'   in "Event". The difference between this and Event is that the genomic
#'   coordinates can be centered around a different `Event`, `Gene` or region
#'   as given in `seqname/start/end`. If `norm_event` is different to
#'   `Event`, `norm_event` will be used for normalisation and `Event` will be
#'   used to define the genomic coordinates of the viewing window. `norm_event`
#'   is required if `Event` is not set and `condition` is set.
#' @param bases_flanking (Default = `100`) How many bases flanking the zoomed
#'    window. Useful when
#'    used in conjunction with zoom_factor == 0. E.g. for a given region of
#'    chr1:10000-11000, if `zoom_factor = 0` and `bases_flanking = 100`, the
#'    region chr1:9900-11100 will be displayed.
#' @name getCoverageData-methods
#' @md
NULL

#' @describeIn getCoverageData-methods Get coverage / genome data for plotting
#' coverage plots
#' @export
getCoverageData <- function(
        se,
        Event, Gene,
        seqname, start, end,
        coordinates,
        strand = c("*", "+", "-"),
        zoom_factor = 0.2, 
        bases_flanking = 100,
        tracks,
        condition
) {    
    args <- as.list(match.call())
    args[["se"]] <- NULL
    for(argname in names(args)) {
        args[[argname]] <- eval(args[[argname]], parent.frame())
    }
    args[["se"]] <- se
    args[["cov_data"]] <- ref(se)
    
    # Interpret coordinates
    if (
        !all(c("seqname", "start", "end") %in% names(args)) &
        "coordinates" %in% names(args)
    ) {
        args[["seqname"]] <- tstrsplit(coordinates, 
            split = ":", fixed=TRUE)[[1]]
        rangetxt <- tstrsplit(coordinates, split = ":", fixed=TRUE)[[2]]
        rangetxt <- tstrsplit(rangetxt, split = "/", fixed=TRUE)[[1]]
        args[["start"]] <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[1]])
        args[["end"]] <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[2]])
    }
    strand <- match.arg(strand)
    if(!is_valid(strand)) strand <- "*"
    args[["strand"]] <- strand
    
    # Evaluate view_chr, view_start, view_end, and check arguments
    args <- .gCD_validate_args(args)

    # Retrieve colData
    colData <- .gCD_retrieve_colData(args)
    
    # Retrieve in-range events and corresponding normalization values
    normData <- .gCD_retrieve_norms(args, colData)

    # Retrieve genome annotations
    annotations <- .gCD_retrieve_annotations(args)
    
    raw_cov <- .gCD_retrieve_raw_cov(args, colData)

    juncData <- .gCD_retrieve_junc(args, colData)

    # Remove large objects prior to returning
    args[["se"]] <- args[["cov_data"]] <- NULL
    return(covDataObject(
        args = args,
        annotations = annotations,
        colData = colData,
        covData = raw_cov,
        juncData = juncData,
        normData = normData
    ))
}

#' @describeIn getCoverageData-methods Get coverage / genome data for plotting
#' coverage plots
#' @export
getGenomeData <- function(
        reference_path,
        Event, Gene,
        seqname, start, end,
        coordinates,
        strand = c("*", "+", "-"),
        zoom_factor = 0.2, 
        bases_flanking = 100
) {
    if (!file.exists(file.path(reference_path, "cov_data.Rds")))
        .log("Given reference_path is not a valid SpliceWiz reference")

    args <- as.list(match.call())
    for(argname in names(args)) {
        args[[argname]] <- eval(args[[argname]], parent.frame())
    }
    args[["cov_data"]] <- readRDS(file.path(reference_path, "cov_data.Rds"))
    
    # Interpret coordinates
    args <- .gCD_validate_args_coords(args)

    args <- .gCD_validate_args(args)

    annotations <- .gCD_retrieve_annotations(args)
    
    args[["cov_data"]] <- NULL
    return(covDataObject(
        args = args,
        annotations = annotations
    ))
}

#' @export
gCD_plotCoverage <- function(
    obj, Event,
    view_start, view_end,
    strand = c("*", "+", "-"),
    tracks, condition,
    ribbon_mode = c("sd", "ci", "sem", "none"),
    diff_mode = c("none", "t-test"),
    reverseGenomeCoords = FALSE,
    condensed = FALSE
) {
    args <- obj@args
    if(!missing(view_start))  args[["view_start"]] <- view_start
    if(!missing(view_end))  args[["view_end"]] <- view_end
    args[["reverseGenomeCoords"]] <- reverseGenomeCoords
    if(args[["view_start"]] > args[["view_end"]]) {
        args[["reverseGenomeCoords"]] <- !reverseGenomeCoords
        args[["view_start"]] <- args[["view_start"]] + args[["view_end"]]
        args[["view_end"]] <- args[["view_start"]] - args[["view_end"]]
        args[["view_start"]] <- args[["view_start"]] - args[["view_end"]]
    }

    if(!missing(tracks)) args[["tracks"]] <- tracks
    if(!missing(condition)) {
        args[["condition"]] <- condition
    } else if(missing(tracks)) {
        args[["condition"]] <- NULL
    }

    # sanity check condition / tracks against colData
    colData <- obj@colData
    sampleList <- list()
    samples_to_check <- c()
    if("condition" %in% names(args)) {
        if(args[["condition"]] %in% colnames(colData)) {
            for(cond_elem in args[["tracks"]]) {
                if(any(cond_elem %in% colData[, args[["condition"]]])) {
                    sampleList[[cond_elem]] <- rownames(colData)[
                        colData[, args[["condition"]]] == cond_elem]
                    samples_to_check <- c(samples_to_check,
                        sampleList[[cond_elem]])
                } else {
                    # ignore
                }
            }
        } else {
            .log(paste("In gCD_plotCoverage,",
                "condition is not a recognised column in colData"
            ))
        }
    } else {
        for(samp in args[["tracks"]]) {
            if(samp %in% rownames(colData)) {
                sampleList[[samp]] <- samp
                samples_to_check <- c(samples_to_check,
                    sampleList[[samp]])
            }
        }
    }
    args[["sampleList"]] <- sampleList

    
    # Junction strand is always same as requested strand
    # But need to check strandedness of RNA-seq data before deciding coverage

    if(
            !missing(strand) && 
            length(strand) == 1 && 
            strand %in% c("*", "+", "-")
    ) {
        args[["strand"]] <- strand
    }

    args[["view_strand_jn"]] <- args[["strand"]]
    if(args[["strand"]] != "*") {
        if(all(obj@normData[["sampleStrand"]][samples_to_check] == -1)) {
            if(args[["strand"]] == "+") {
                args[["view_strand"]] <- "-"
            } else {
                args[["view_strand"]] <- "+"
            }
        }
    } else {
        args[["view_strand"]] <- "*"
    }
    
    if(!missing(Event)) args[["Event"]] <- Event
    
    if(!("Event" %in% names(args)) && "condition" %in% names(args)) {
        .log(paste("In gCD_plotCoverage,",
            "for plotting by condition, normalizing `Event` must be supplied"
        ))
    }

    highlight_gr <- list()
    if(
            "Event" %in% names(args) && 
            args[["Event"]] %in% rownames(obj@normData$rowData)
    ) {
        row <- obj@normData$rowData[args[["Event"]],]
        if (row$EventType %in% c("MXE", "SE")) {
            highlight_gr[[1]] <- coord2GR(c(row$Event1a, row$Event2a))
        } else {
            highlight_gr[[1]] <- coord2GR(row$Event1a)
        }
        if (row$EventType %in% c("MXE")) {
            highlight_gr[[2]] <- coord2GR(c(row$Event1b, row$Event2b))
        } else if (row$EventType %in%  c("SE", "A3SS", "A5SS", "ALE", "AFE")) {
            highlight_gr[[2]] <- coord2GR(row$Event1b)
        }    
    }
    args[["highlight_gr"]] <- highlight_gr

    DTlist <- obj@annotations
    DTlist$reduced.DT <- .gcd_highlight_anno(
        DTlist$reduced.DT, args[["highlight_gr"]], 
        plot_key_isoforms = FALSE,
        filtered_events = NULL
    )

    if (condensed != TRUE & nrow(DTlist$transcripts.DT) <= 100) {
        DTlist$condense_this <- FALSE
        DTlist$transcripts.DT[, c("group_id") := get("transcript_id")]
        DTlist$reduced.DT[, c("group_id") := get("transcript_id")]
    } else {
        DTlist$condense_this <- TRUE
        DTlist$transcripts.DT[, c("group_id") := get("gene_id")]
        DTlist$reduced.DT[transcripts.DT, on = "transcript_id",
            c("group_id") := get("gene_id")]
    }

    DTplotlist <- .gCD_stack_anno(
        DTlist, 
        args[["view_start"]], args[["view_end"]], 
        args[["reverseGenomeCoords"]]
    )
    
    # p_ref <- .plot_view_ref_fn_plotDTlist(
        # DTplotlist,
        # args[["view_chr"]], args[["view_start"]], args[["view_end"]],
        # args[["highlight_gr"]], args[["reverseGenomeCoords"]]
    # )
    
    if("condition" %in% names(args)) {
        # compile normalized coverage data
        cov <- .gCD_getCoverage(obj, args, normalize = TRUE)
        
        # compile junction data
        junc <- .gCD_getPSI(obj, args, cov)

        # compile statistics (if required)
    } else {
        # compile raw coverage data per sample
        cov <- .gCD_getCoverage(obj, args)

        # compile raw junction data
        junc <- .gCD_getJuncRaw(obj, args, cov)
    }
    
    # Plot stats if applicable
    cov_stats <- list()
    diff_stats <- data.table()
    
    ribbon_mode <- match.arg(ribbon_mode)
    if(!is_valid(ribbon_mode)) ribbon_mode <- "none"
    args[["ribbon_mode"]] <- ribbon_mode
    if("condition" %in% names(args)) {
        cov_stats <- .gCD_covStats(cov, ribbon_mode)
        
        diff_mode <- match.arg(diff_mode)
        if(diff_mode == "t-test" & length(args[["sampleList"]]) >= 2) {
            diff_stats <- .gCD_ttest(cov[[1]], cov[[2]])
        }
    }
    
    return(covPlotObject(
        args = args,
        cov = cov,
        junc = junc,
        cov_stats = cov_stats,
        diff_stats = diff_stats,
        annotation = DTplotlist
    ))
}

#' @export
gCD_plotGenome <- function(
    obj, Event,
    view_start, view_end,
    reverseGenomeCoords = FALSE,
    condensed = FALSE,
    interactive = FALSE
) {
    if(missing(view_start)) view_start <- obj@args$view_start
    if(missing(view_end)) view_end <- obj@args$view_end

    if(view_start > view_end) {
        reverseGenomeCoords <- !reverseGenomeCoords
        view_start <- view_start + view_end
        view_end <- view_start - view_end
        view_start <- view_start - view_end
    }

    highlight_gr <- list()
    if(!missing(Event) && Event %in% rownames(obj@normData$rowData)) {
        row <- obj@normData$rowData[Event,]
        if (row$EventType %in% c("MXE", "SE")) {
            highlight_gr[[1]] <- coord2GR(c(row$Event1a, row$Event2a))
        } else {
            highlight_gr[[1]] <- coord2GR(row$Event1a)
        }
        if (row$EventType %in% c("MXE")) {
            highlight_gr[[2]] <- coord2GR(c(row$Event1b, row$Event2b))
        } else if (row$EventType %in%  c("SE", "A3SS", "A5SS", "ALE", "AFE")) {
            highlight_gr[[2]] <- coord2GR(row$Event1b)
        }    
    }
    
    DTlist <- obj@annotations
    DTlist$reduced.DT <- .gcd_highlight_anno(
        DTlist$reduced.DT, highlight_gr, 
        plot_key_isoforms = FALSE,
        filtered_events = NULL
    )

    if (condensed != TRUE & nrow(DTlist$transcripts.DT) <= 100) {
        DTlist$condense_this <- FALSE
        DTlist$transcripts.DT[, c("group_id") := get("transcript_id")]
        DTlist$reduced.DT[, c("group_id") := get("transcript_id")]
    } else {
        DTlist$condense_this <- TRUE
        DTlist$transcripts.DT[, c("group_id") := get("gene_id")]
        DTlist$reduced.DT[transcripts.DT, on = "transcript_id",
            c("group_id") := get("gene_id")]
    }

    DTplotlist <- .gCD_stack_anno(
        DTlist, view_start, view_end, reverseGenomeCoords
    )
    
    p <- .plot_view_ref_fn_plotDTlist(
        DTplotlist,
        obj@args$view_chr, view_start, view_end,
        highlight_gr, reverseGenomeCoords
    )
    
    if(interactive) {
        # Remove legend for p_ref; this causes trouble for plotly
        for (i in seq_len(length(p$pl$x$data))) {
            p$pl$x$data[[i]]$showlegend <- FALSE
        }
        return(p$pl)
    } else {
        out <- p$gp + theme(legend.position = "none") +
            labs(x = paste("Chromosome", obj@args$view_chr))
        
        ref_ymin <- min(layer_scales(out)$y$range$range)
        ref_ymax <- max(layer_scales(out)$y$range$range)
        if(!reverseGenomeCoords) {
            plotViewStart <- view_start
            plotViewEnd <- view_end
        } else {
            plotViewStart <- view_end
            plotViewEnd <- view_start     
        }

        out <- out + 
            scale_x_continuous(labels = label_number(scale_cut = cut_si(""))) +
            coord_cartesian(
                xlim = c(plotViewStart, plotViewEnd),
                ylim = c(ref_ymin - 1, ref_ymax + 1),
                expand = FALSE
            )
        return(out)
    }
}

.gCD_validate_args <- function(args) {
    if(!("reference_path" %in% names(args))) .gCD_validate_args_se(args)
    return(.gCD_validate_args_loci(args))
}

.gCD_validate_args_se <- function(args) {
    if (!("se" %in% names(args)) || !is(args[["se"]], "NxtSE"))
        .log("In getCoverageData, `se` must be a valid `NxtSE` object")

    # Warn if old NxtSE object
    if(!("row_gr" %in% names(metadata(args[["se"]]))))
        .log(paste(
            "In getCoverageData,", 
            "we recommend updating `se` to the latest version",
            "using update_NxtSE()"
        ), "warning")

    if (!all(file.exists(covfile(args[["se"]]))))
        .log(paste("In getCoverageData,",
            "COV files are not defined in se.",
            "Please supply the correct paths of the COV files",
            "using covfile(se) <- vector_of_correct_COVfile_paths"))

    # Check condition and tracks
    # - don't check number of tracks - irrelevant at this stage
    
    # - check condition is of length 1
    if("condition" %in% names(args)) {
        if(length(args[["condition"]]) != 1)
            .log(paste("In getCoverageData,", "condition must be of length 1"))
            
        if(!(args[["condition"]] %in% names(colData(args[["se"]]))))
            .log(paste("In getCoverageData,", 
                "condition must be a valid column name in colData(se)"))

        if(!("tracks" %in% names(args))) 
            .log(paste("In getCoverageData,", 
                "condition is defined but tracks is missing"))

        condition_options <- unique(
            colData(args[["se"]])[, args[["condition"]]]
        )
        if (!all(args[["tracks"]] %in% condition_options))
            .log(paste("In getCoverageData,",
                "some tracks do not match valid condition names in",
                args[["condition"]]))

    } else if("tracks" %in% names(args)) {
        if (!all(args[["tracks"]] %in% colnames(args[["se"]])))
            .log(paste("In getCoverageData,",
                "some tracks do not match valid sample names in se"))
    }
}

.gCD_validate_args_coords <- function(args) {
    # Interpret coordinates
    if (
        !all(c("seqname", "start", "end") %in% names(args)) &
        "coordinates" %in% names(args)
    ) {
        args[["seqname"]] <- tstrsplit(args[["coordinates"]], 
            split = ":", fixed=TRUE)[[1]]
        rangetxt <- tstrsplit(args[["coordinates"]], 
            split = ":", fixed=TRUE)[[2]]
        rangetxt <- tstrsplit(rangetxt, split = "/", fixed=TRUE)[[1]]
        args[["start"]] <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[1]])
        args[["end"]] <- as.numeric(tstrsplit(
            rangetxt, split = "-", fixed=TRUE)[[2]])
    }
    return(args)
}

# Checks Gene and loci. Only this is run if plotGenome is run
.gCD_validate_args_loci <- function(args) {
    if (!("se" %in% names(args)) || !is(args[["se"]], "NxtSE")) {
        if(!("cov_data" %in% names(args)))
            .log("In getGenomeData, `cov_data` is missing")
        cov_data <- args[["cov_data"]]
    } else {
        cov_data <- ref(args[["se"]])    
    }
    args[["seqInfo"]] <- cov_data$seqInfo
    # Check we know where to plot
    if (
        !any(c("Event", "Gene") %in% names(args)) &
        !all(c("seqname", "start", "end") %in% names(args))
    ) {
        .log(paste("In getCoverageData / getGenomeData,",
            "Event or Gene cannot be empty, unless coordinates are provided"))
    } else if (all(c("seqname", "start", "end") %in% names(args))) {
        args[["view_chr"]] <- as.character(args[["seqname"]])
        args[["view_start"]] <- args[["start"]]
        args[["view_end"]] <- args[["end"]]
    } else if ("Gene" %in% names(args)) {
        if (
            !(args[["Gene"]] %in% cov_data$geneList$gene_id) &
            !(args[["Gene"]] %in% cov_data$geneList$gene_name)
        ) {
            .log(paste("In getCoverageData / getGenomeData,",
                args[["Gene"]], "is not a valid gene symbol or gene_id"))
        }
        if (!(args[["Gene"]] %in% cov_data$geneList$gene_id)) {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_name") == args[["Gene"]]])
            if (nrow(gene.df) != 1) {
                .log(paste("In getCoverageData / getGenomeData,",
                    args[["Gene"]],
                    "is an ambiguous name referring to 2 or more genes.",
                    "Please provide its gene_id instead"))
            }
        } else {
            gene.df <- as.data.frame(
                cov_data$geneList[get("gene_id") == args[["Gene"]]])
            if (nrow(gene.df) != 1) {
                .log(paste("In getCoverageData / getGenomeData,", 
                    args[["Gene"]],
                    "is an ambiguous gene_id referring to 2 or more genes."))
            }
        }
        args[["view_chr"]] <- as.character(gene.df$seqnames)
        args[["view_start"]] <- gene.df$start
        args[["view_end"]] <- gene.df$end
    } else if(!("Event" %in% names(args))) {
        .log(paste("In getCoverageData,",
            "Event must be given if no other loci information is given"))
    } else {
        # Only "Event" given - check this at later step)
        return(.gCD_validate_args_event(args))
    }
    # determine params here - TODO
    return(.gCD_determine_loci(args))
}

# Checks whether Event given is valid.
.gCD_validate_args_event <- function(args) {
    cov_data <- ref(args[["se"]])
    if (!(args[["Event"]] %in% rownames(args[["se"]])))
        .log(paste("In getCoverageData,", args[["Event"]],
            "is not a valid IR or alternate splicing event in rowData(se)"))
    
    rowData <- rowData(args[["se"]])[args[["Event"]], ]
    if(nrow(rowData) > 1) rowData <- rowData[1,]
    
    args[["view_chr"]] <- tstrsplit(rowData$EventRegion, split = ":")[[1]]
    temp1 <- tstrsplit(rowData$EventRegion, split = "/")
    temp2 <- tstrsplit(temp1[[1]], split = ":")[[2]]
    args[["view_start"]] <- as.numeric(tstrsplit(temp2, split = "-")[[1]])
    args[["view_end"]] <- as.numeric(tstrsplit(temp2, split = "-")[[2]])
    
    return(.gCD_determine_loci(args))
}

.gCD_determine_loci <- function(args) {
    if (!(args[["view_chr"]] %in% names(args[["seqInfo"]])))
        .log(paste("In getCoverageData / getGenomeData,", 
            args[["view_chr"]],
            "is not a valid chromosome reference name in the given genome"))

    if ("bases_flanking" %in% names(args)) {
        if(
            !is.numeric(args[["bases_flanking"]]) || 
            args[["bases_flanking"]] < 0
        ) .log(paste("In getCoverageData / getGenomeData,",
            "bases_flanking must be a non-negative number"))
    } else {
        args[["bases_flanking"]] <- 0
    }

    view_length <- args[["view_end"]] - args[["view_start"]]
    if (!is.numeric(view_length) || view_length < 0)
        .log(paste("In getCoverageData / getGenomeData,",
            "view_length must be a non-negative number"))

    if (("zoom_factor" %in% names(args))) {
        tryCatch({
            args[["zoom_factor"]] <- as.numeric(args[["zoom_factor"]])
        }, error = function(e) {
            args[["zoom_factor"]] <- 0
        })
    } else {
        args[["zoom_factor"]] <- 0
    }
    
    view_center <- (args[["view_start"]] + args[["view_end"]]) / 2
    new_view_length <- view_length * 3^args[["zoom_factor"]] + 
        2 * args[["bases_flanking"]]
    
    view_start <- round(view_center - new_view_length / 2)
    view_end <- round(view_center + new_view_length / 2)
    # Validate genomic window and shift if invalid
    if (view_start < 1) view_start <- 1
    seqInfo <- args[["seqInfo"]][args[["view_chr"]]]
    seqmax <- GenomeInfoDb::seqlengths(seqInfo)
    if(seqmax < 3) .log(paste(
        "In getCoverageData / getGenomeData",
        "chromosome", args[["view_chr"]], "has sequence length of", seqmax,
        "which is not allowed"
    ))
    if (view_end > seqmax) {
        view_end <- seqmax - 1
        view_start <- view_end - new_view_length
        if(view_start < 1) view_start <- 1
    }
    args[["view_start"]] <- view_start
    args[["view_end"]] <- view_end
    return(args)    
}

################################################################################

# Retrieve relevant colData
.gCD_retrieve_colData <- function(args) {

    if(!("tracks" %in% names(args))) {
        return(data.frame())
    }
    tracks <- args[["tracks"]]
    colData <- as.data.frame(colData(args[["se"]]))
    sampleNames <- colnames(args[["se"]])
    
    if("condition" %in% names(args)) {
        cond <- args[["condition"]]
        condStates <- colData[, cond]
        samples <- sampleNames[condStates %in% tracks]
        colData <- colData[samples %in% sampleNames, cond, drop = FALSE]
    } else {
        colData <- colData[args[["tracks"]] %in% sampleNames, , drop = FALSE]
    }
    return(colData)
}

################################################################################

# Retrieve relevant raw coverage
.gCD_retrieve_raw_cov <- function(args, colData) {

    samples <- rownames(colData)
    covfiles <- covfile(args[["se"]])[samples]
    
    pos <- list()
    neg <- list()
    uns <- list()
    for(i in seq_len(length(samples))) {
        pos[[i]] <- getCoverage(
            file = covfiles[i], 
            seqname = args[["view_chr"]], 
            start = args[["view_start"]] - 1, end = args[["view_end"]], 
            strand = c("+")
        )
        neg[[i]] <- getCoverage(
            file = covfiles[i], 
            seqname = args[["view_chr"]], 
            start = args[["view_start"]] - 1, end = args[["view_end"]], 
            strand = c("-")
        )
        uns[[i]] <- getCoverage(
            file = covfiles[i], 
            seqname = args[["view_chr"]], 
            start = args[["view_start"]] - 1, end = args[["view_end"]], 
            strand = c("*")
        )
    }
    names(pos) <- names(neg) <- names(uns) <- samples
    return(list(
        pos = pos,
        neg = neg,
        uns = uns
    ))
}

# Retrieve relevant raw coverage
.gCD_retrieve_junc <- function(args, colData) {

    samples <- rownames(colData)
    
    # Retrieve a list of in-range events
    view_gr <- GRanges(
        seqnames = args[["view_chr"]],
        ranges = IRanges(
            start = args[["view_start"]], end = args[["view_end"]]
        ),
        strand = "*"
    )

    OL <- findOverlaps(junc_gr(args[["se"]]), view_gr)

    junc_counts <- junc_counts(args[["se"]])[
        unique(from(OL)),
        samples
    ]
    junc_counts_uns <- junc_counts_uns(args[["se"]])[
        unique(from(OL)),
        samples
    ]
    junc_PSI <- junc_PSI(args[["se"]])[
        unique(from(OL)),
        samples
    ]

    return(list(
        junc_gr = junc_gr(args[["se"]])[unique(from(OL))],
        junc_counts = as.matrix(junc_counts),
        junc_counts_uns = as.matrix(junc_counts_uns),
        junc_PSI = as.matrix(junc_PSI)
    ))
}


################################################################################

# Retrieve in-range events and corresponding normalization values

.gCD_retrieve_norms <- function(args, colData) {

    # Retrieve a list of in-range events
    view_gr <- GRanges(
        seqnames = args[["view_chr"]],
        ranges = IRanges(
            start = args[["view_start"]], end = args[["view_end"]]
        ),
        strand = "*"
    )

    OL <- findOverlaps(row_gr(args[["se"]]), view_gr)
    
    event_gr <- row_gr(args[["se"]])[unique(from(OL))]
    names(event_gr) <- rownames(args[["se"]])[unique(from(OL))]
    
    norms <- assay(args[["se"]], "Depth")[
        names(event_gr),
        rownames(colData)
    ]

    rowData <- rowData(args[["se"]])[unique(from(OL)), ]
    rowData <- as.data.frame(rowData)

    # Get strand data
    sampleStrand <- sampleQC(args[["se"]][, rownames(colData)])$strand
    names(sampleStrand) <- rownames(colData)
    
    return(list(
        event_gr = event_gr,
        norms = norms,
        rowData = rowData,
        sampleStrand = sampleStrand
    ))
}

################################################################################

# Retrieve relevant annotations from cov_data

.gCD_retrieve_annotations <- function(args) {
    view_chr <- args[["view_chr"]]
    view_start <- args[["view_start"]]
    view_end <- args[["view_end"]]

    transcripts.DT <- args[["cov_data"]]$transcripts[
        get("seqnames") == view_chr &
        get("start") <= view_end + (view_end - view_start) &
        get("end") >= view_start - (view_end - view_start)
    ]
    setorderv(transcripts.DT, c("transcript_support_level", "width"))

    reduced.DT <- args[["cov_data"]]$elements[
        get("transcript_id") %in% transcripts.DT$transcript_id]
    reduced.DT <- reduced.DT[get("type") %in% c("CDS", "exon", "intron")]

    # Transfer feature_id from exons -> CDS
    CDS.DT <- reduced.DT[get("type") == "CDS"]
    if(nrow(CDS.DT) > 0) {
        exons.DT <- reduced.DT[get("type") == "exon"]
        introns.DT <- reduced.DT[get("type") == "intron"]

        exons.gr <- .grDT(exons.DT)
        CDS.gr <- .grDT(CDS.DT)
        OL <- findOverlaps(exons.gr, CDS.gr)
        
        OL.DT <- data.table(
            from = OL@from, to = OL@to
        )
        OL.DT[, c("feature_id", "exon_trid", "cds_trid") := list(
            exons.DT$feature_id[get("from")],
            exons.DT$transcript_id[get("from")],
            CDS.DT$transcript_id[get("to")]
        )]
        OL.DT <- OL.DT[get("exon_trid") == get("cds_trid")]
        CDS.DT$feature_id[OL.DT$to] <- OL.DT$feature_id
        
        reduced.DT <- rbind(exons.DT, CDS.DT, introns.DT)
    }

    transcripts.DT <- transcripts.DT[
        get("transcript_id") %in% reduced.DT$transcript_id]

    return(list(
        transcripts.DT = transcripts.DT,
        reduced.DT = reduced.DT
    ))
}

################################################################################

.gcd_highlight_anno <- function(
        reduced.DT, highlight_gr,
        plot_key_isoforms = FALSE,
        filtered_events = NULL
) {
    introns <- reduced.DT[get("type") == "intron"]
    introns[, c("highlight") := "0"]
    exons <- reduced.DT[get("type") == "exon"]
    exons[, c("highlight") := "0"]
    misc <- reduced.DT[get("type") == "CDS"]
    misc[, c("highlight") := "0"]

    tr_filter <- c()
    if (length(highlight_gr) == 1) {
        # IR / RI only
        gr <- highlight_gr[[1]]
        introns.gr <- .grDT(introns)
        OL <- findOverlaps(gr, introns.gr)
        introns[OL@to, c("highlight") := "1"]
        OL2 <- findOverlaps(gr, introns.gr, type = "equal")
        introns[OL2@to, c("highlight") := "2"]
        
        tr_filter <- unique(introns[get("highlight") != "0"]$transcript_id)
    } else if (length(highlight_gr) == 2) {
        AS_count <- 1
        for (event in highlight_gr) {
            tr <- list()
            for(i in seq_len(length(event))) {
                OL <- findOverlaps(event[i], .grDT(introns), type = "equal")
                tr[[i]] <- introns[OL@to]$transcript_id
            }
            tr_final <- NULL
            if(length(event) == 2) {
                tr_final <- intersect(tr[[1]], tr[[2]])
            } else {
                tr_final <- tr[[1]]
            }
            
            if(length(tr_final) > 0) {
                # Highlight introns that match exact junction
                gr <- event
                introns.gr <- .grDT(introns)
                OL <- findOverlaps(gr, introns.gr, type = "equal")

                introns[
                    seq_len(nrow(introns)) %in% OL@to & 
                    get("transcript_id") %in% tr_final, 
                    c("highlight") := as.character(AS_count)
                ]

                # Remove novel transcripts if not all introns highlighted
                introns_novel <- introns[
                    grepl("novel", get("transcript_id")) &
                    get("highlight") == as.character(AS_count)
                ]
                introns_novel_noHL <- introns[
                    get("transcript_id") %in% introns_novel$transcript_id &
                    get("highlight") == "0"
                ]
                if(nrow(introns_novel_noHL) > 0) {
                    introns[
                        get("transcript_id") %in% introns_novel_noHL$transcript_id,
                        c("highlight") := "0"
                    ]
                    tr_final <- setdiff(tr_final, 
                        introns_novel_noHL$transcript_id)
                }
                
                coord_keys_start <- end(gr[1]) + 1
                coord_keys_end <- start(gr[1]) - 1
                if (length(gr) == 2) {
                    coord_keys_start <- c(coord_keys_start, end(gr[2]) + 1)
                    coord_keys_end <- c(coord_keys_end, start(gr[2]) - 1)
                }
                exons[get("transcript_id") %in% tr_final &
                    (get("start") %in% coord_keys_start | 
                    get("end") %in% coord_keys_end),
                    c("highlight") := as.character(AS_count)]
            }
 
            tr_filter <- c(tr_filter, tr_final)
            AS_count <- AS_count + 1
        }
        
        # transfer highlighting from exons to CDS
        for(tr in unique(exons[get("highlight") != "0"]$transcript_id)) {
            exons_selected <- exons[get("transcript_id") == tr &
                get("highlight") != "0"]
            highlight_id <- exons_selected$highlight[1]
            OL <- findOverlaps(
                .grDT(misc),
                .grDT(exons_selected)
            )
            misc[seq_len(nrow(misc)) %in% unique(OL@from) & 
                get("transcript_id") == tr,
                c("highlight") := highlight_id]
        }
    }
    
    if(!is.null(filtered_events)) {
        # filter vectors
        novelTrID <- preservePut <- InTrID <- c()
        intronlessID <- exons[
            !(get("transcript_id") %in% introns$transcript_id)
        ]$transcript_id
        
        filterByDT <- as.data.table(coord2GR(filtered_events))
        filterByDT <- filterByDT[, c("seqnames", "start", "end"),
            with = FALSE]

        # Remove novel transcripts if at least 1 junction not represented
        intronsOut <- introns[!filterByDT, on = c("seqnames", "start", "end")]
        if(nrow(intronsOut) > 0) {
            novelTrID <- intronsOut$transcript_id
            novelTrID <- novelTrID[grepl("novel", novelTrID)]
        }
        
        intronsIn <- introns[filterByDT, on = c("seqnames", "start", "end")]
        InTrID <- intronsIn$transcript_id
        InTrID <- InTrID[!(InTrID %in% novelTrID)]

        # Remove all novel putative tandem transcripts unless both introns
        #   in viewing frame
        intronsPut <- intronsIn[grepl("novelPutTrID", get("transcript_id"))]
        if(nrow(intronsPut) > 0) {
            preservePut <- intronsPut$transcript_id[
                duplicated(intronsPut$transcript_id)]
        }

        introns <- introns[
            # Retain if not a novel junction with no in-view junctions expressed
            !(get("transcript_id") %in% novelTrID) & (

                # Retain if important
                (get("transcript_id") %in% tr_filter) |            

                # Retain if annotated and any in-view junctions expressed
                (get("transcript_id") %in% InTrID) |
                
                # Retain if both junctions of TJ-Puts are expressed
                (get("transcript_id") %in% preservePut)
            )
        ]
        exons <- exons[
            get("transcript_id") %in% c(introns$transcript_id, intronlessID)
        ]
        misc <- misc[
            get("transcript_id") %in% c(introns$transcript_id, intronlessID)
        ]
        
    }
    
    if(plot_key_isoforms) {
        introns <- introns[get("transcript_id") %in% tr_filter]
        exons <- exons[get("transcript_id") %in% tr_filter]
        misc <- misc[get("transcript_id") %in% tr_filter]
    } 
    return(rbind(introns, exons, misc))    
}

.gCD_stack_anno <- function(
        DTlist, view_start, view_end, reverseGenomeCoords = FALSE
) {
    transcripts.DT <- DTlist$transcripts.DT
    reduced.DT <- DTlist$reduced.DT
    condense_this <- DTlist$condense_this
    
    exonRanges <- .plot_view_ref_fn_getExonRanges(
        reduced.DT, transcripts.DT,
        view_start, view_end
    )
    
    group.grl <- split(.grDT(transcripts.DT), transcripts.DT$group_id)
    group.DT <- as.data.table(range(group.grl))
    group.DT$group <- NULL
    data.table::setnames(group.DT, "group_name", "group_id")
    # apply plot_order on transcripts.DT
    OL <- findOverlaps(.grDT(group.DT), .grDT(group.DT), ignore.strand = TRUE)
    group.DT$plot_level <- 1
    cur_level <- 1
    while (any(group.DT$plot_level == cur_level)) {
        j <- match(cur_level, group.DT$plot_level)
        repeat {
            bump_up_trs <- unique(OL@to[OL@from == j])
            bump_up_trs <- bump_up_trs[bump_up_trs > j]
            bump_up_trs <- bump_up_trs[
                group.DT$plot_level[bump_up_trs] == cur_level]
            if (length(bump_up_trs) > 0)
                group.DT[bump_up_trs, c("plot_level") := cur_level + 1]

            j <- j + match(cur_level, group.DT$plot_level[-seq_len(j)])
            if (is.na(j)) break
        }
        cur_level <- cur_level + 1
    }

    if (condense_this == TRUE) {
        group.DT[transcripts.DT, on = "group_id",
            c("group_name", "group_biotype") :=
            list(get("i.gene_name"), get("i.gene_biotype"))]
    } else {
        group.DT[transcripts.DT, on = "group_id",
            c("group_name", "group_biotype") :=
            list(get("i.transcript_name"), get("i.transcript_biotype"))]
    }

    group.DT <- group.DT[get("end") > view_start & get("start") < view_end]

    reduced.DT$group_id <- factor(reduced.DT$group_id,
        unique(group.DT$group_id), ordered = TRUE)
    reduced.DT[group.DT, on = "group_id",
        c("plot_level") := get("i.plot_level")]

    setorderv(reduced.DT, "highlight")

    return(list(
        group.DT = group.DT,
        reduced.DT = reduced.DT,
        condense_this = condense_this,
        exonRanges = exonRanges
    ))
}

.gCD_plotRef <- function(
    DTplotlist, args,    
    reverseGenomeCoords = FALSE,
    add_information = TRUE,
    interactive = FALSE
) {
    view_chr <- args[["view_chr"]]
    view_start <- args[["view_start"]]
    view_end <- args[["view_end"]]

    group.DT <- copy(DTplotlist$group.DT)

    # use one paste function
    if(add_information) {
        group.DT[, c("left_extra", "right_extra") := list("","")]
        if(reverseGenomeCoords) {
            group.DT[get("strand") == "-", c("right_extra") := " -->"]
            group.DT[get("strand") == "+", c("left_extra") := "<-- "]
        } else {
            group.DT[get("strand") == "+", c("right_extra") := " -->"]
            group.DT[get("strand") == "-", c("left_extra") := "<-- "]
        }
        group.DT[, c("display_name") := paste0(
            get("left_extra"), 
            get("group_name"),
            " (", get("strand"), ") ",
            get("group_biotype"),
            get("right_extra")
        )]
        group.DT[, c("left_extra", "right_extra") := list(NULL,NULL)]

        group.DT[, c("disp_x") := 0.5 * (get("start") + get("end"))]
        group.DT[get("start") < view_start & get("end") > view_start,
            c("disp_x") := 0.5 * (view_start + get("end"))]
        group.DT[get("end") > view_end & get("start") < view_end,
            c("disp_x") := 0.5 * (get("start") + view_end)]
        group.DT[get("start") < view_start & get("end") > view_end,
            c("disp_x") := 0.5 * (view_start + view_end)]    
    }

    reduced <- copy(DTplotlist$reduced.DT)
    reduced <- reduced[!is.na(reduced$plot_level)]
    condense_this <- DTplotlist$condense_this
    exonRanges <- DTplotlist$exonRanges

    # Hover Text annotation
    reduced[, c("Information") := ""]
    reduced[get("type") %in% c("exon", "CDS"), c("Information") := paste(
        paste(get("transcript_id"), "exon", get("aux_id")),
        paste0("(", get("feature_id"), ")"),
        paste0(get("seqnames"), ":", get("start"), "-", get("end"), "/", 
            get("strand")),
        sep = "\n"
    )]
    reduced[get("type") == "intron", c("Information") := paste(
        get("feature_id"), 
        paste0(get("seqnames"), ":", get("start"), "-", get("end"), "/", 
            get("strand")),
        sep = "\n"
    )]
    
    reduced <- as.data.frame(reduced)
    p <- suppressWarnings(ggplot(reduced, aes(text = get("Information"))))
    
    if (nrow(subset(reduced, type = "intron")) > 0) {
        reducedIntrons <- reduced[reduced$type == "intron", ]
        reducedIntronsExpanded <- c()
        for(i in seq_len(nrow(reducedIntrons))) {
            reducedIntronsExpanded <- rbind(reducedIntronsExpanded, data.frame(
                start = seq(reducedIntrons$start[i], reducedIntrons$end[i],
                    length.out = 10),
                end = seq(reducedIntrons$start[i], reducedIntrons$end[i],
                    length.out = 10),
                plot_level = reducedIntrons$plot_level[i],
                highlight = reducedIntrons$highlight[i],
                Information = reducedIntrons$Information[i]              
            ))
        }
        p <- p + geom_line(data = reducedIntronsExpanded,
            aes(x = get("start"), y = get("plot_level"),
            color = get("highlight"), group = get("Information")))
    }
    if (nrow(reduced[reduced$type != "intron", ]) > 0) {
        p <- p + geom_rect(data = reduced[reduced$type != "intron", ],
            aes(xmin = get("start"), xmax = get("end"),
                ymin = get("plot_level") - 0.1 -
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                ymax = get("plot_level") + 0.1 +
                    ifelse(get("type") %in%
                        c("CDS", "start_codon", "stop_codon"), 0.1, 0),
                fill = get("highlight")
            )
        )
    }
    
    col_highlights <- sort(unique(DTplotlist$reduced.DT$highlight))
    col_highlights <- sub("0", "black", col_highlights)
    col_highlights <- sub("1", "blue", col_highlights)
    col_highlights <- sub("2", "red", col_highlights)
    p <- p + scale_color_manual(values = col_highlights) +
        scale_fill_manual(values = col_highlights)    
    
    p <- p + theme_white_legend_plot_track +
        theme(axis.text.y = element_blank(), axis.title.y = element_blank(),
            legend.title = element_blank())
    
    anno <- NULL
    if(add_information) {
        if (condense_this == TRUE) {
            anno <- list(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.5 + 0.3 * 
                    runif(rep(1, nrow(group.DT))),
                text = group.DT$display_name,
                xref = "x", yref = "y", showarrow = FALSE)
        } else {
            anno <- list(
                x = group.DT$disp_x,
                y = group.DT$plot_level - 0.4,
                text = group.DT$display_name,
                xref = "x", yref = "y", showarrow = FALSE)
        }
    }

    if (nrow(group.DT) == 0) {
        max_plot_level <- 1
    } else {
        max_plot_level <- max(group.DT$plot_level)
    }

    if(!interactive) {
        out_p <- p
        if(!is.null(anno)) {
            out_p <- out_p + geom_text(
                data = data.frame(
                    x = anno[["x"]], y = anno[["y"]],
                    Information = anno[["text"]]
                ),
                    aes(x = get("x"), y = get("y"), label = get("Information"))
                )
        }
            
        out_p <- out_p + theme(legend.position = "none") +
            labs(x = paste("Chromosome", view_chr))
        ref_ymin <- min(layer_scales(out_p)$y$range$range)
        ref_ymax <- max(layer_scales(out_p)$y$range$range)
        if(!reverseGenomeCoords) {
            plotViewStart <- view_start
            plotViewEnd <- view_end
        } else {
            plotViewStart <- view_end
            plotViewEnd <- view_start     
        }
        out_p <- out_p + 
            scale_x_continuous(labels = label_number(scale_cut = cut_si(""))) +
            coord_cartesian(
                xlim = c(plotViewStart, plotViewEnd),
                ylim = c(ref_ymin - 1, ref_ymax + 1),
                expand = FALSE
            )
    } else {
        if(!reverseGenomeCoords) {
            out_p <- ggplotly(p, tooltip = "text") %>%
                layout(
                    annotations = anno, dragmode = "pan",
                    xaxis = list(range = c(view_start, view_end),
                        title = paste("Chromosome/Scaffold", view_chr)),
                    yaxis = list(range = c(0, 1 + max_plot_level),
                        fixedrange = TRUE)
                ) 
        } else {
            out_p <- ggplotly(p, tooltip = "text") %>%
                layout(
                    annotations = anno, dragmode = "pan",
                    xaxis = list(
                        range = c(view_end, view_start),
                        title = paste("Chromosome/Scaffold", view_chr)
                    ),
                    yaxis = list(range = c(0, 1 + max_plot_level),
                        fixedrange = TRUE)
                )         
        }
        for (i in seq_len(length(out_p$pl$x$data))) {
            out_p$pl$x$data[[i]]$showlegend <- FALSE
        }    
    }
    
    return(out_p)
}

################################################################################

# Get normalized coverage from obj
.gCD_getCoverage <- function(obj, args, normalize = FALSE) {
    view_start <- args[["view_start"]]
    view_end <- args[["view_end"]]
    view_strand <- args[["view_strand"]]
    Event <- args[["Event"]]
    
    outList <- list()
    sampleList <- args[["sampleList"]]
    
    if(view_strand == "+") {
        cov <- obj@covData$pos
    } else if(view_strand == "-") {
        cov <- obj@covData$neg    
    } else {
        cov <- obj@covData$uns    
    }
    
    for(i in seq_len(length(sampleList))) {
        track <- names(sampleList)[i]
        samples <- sampleList[[i]]
        
        matList <- list()
        for(s in samples) {
            view <- IRanges::Views(cov[[s]], view_start, view_end)
            matList[[s]] <- as.matrix(view[[1]])
        }
        mat <- do.call(cbind, matList)
        colnames(mat) <- samples
        
        # Normalize coverage
        if(normalize) {
            normFactor <- unlist(obj@normData$norms[Event,samples])
            mat <- t(t(mat) / normFactor)
        }
        
        outList[[track]] <- cbind(seq(view_start, view_end), as.data.frame(mat))
        colnames(outList[[track]])[1] <- "x"
        
        if(!normalize & ncol(outList[[track]]) == 2) {
            colnames(outList[[track]])[2] <- "depth"
        }
    }
    
    return(outList)
}

.gCD_binCoverage <- function(cov, divFactor, junc) {
    out <- list()
    outnames <- names(cov)
    
    juncSpares <- c()
    for(i in seq_len(length(junc))) {
        juncSpares <- c(
            juncSpares,
            start(junc[[i]]) - 1,
            end(junc[[i]]) + 1
        )
    }
    juncSpares <- sort(unique(juncSpares))
    
    for(i in seq_len(length(cov))) {
        out[[outnames[i]]] <- .gCD_bin_df(
            cov[[outnames[i]]], 
            divFactor, juncSpares
        )
    }
    return(out)
}

.gCD_bin_df <- function(df, binwidth = 3, spareCoords = c()) {
    DT <- as.data.table(df)
    brks <- seq(1, 
        nrow(DT) + 1, 
        length.out = (nrow(DT) + 1) / binwidth
    )
    if(length(spareCoords) > 0) {
        brks <- c(brks, which(DT$x %in% spareCoords))
    }
    brks <- sort(unique(brks))
    
    bin <- NULL
    DT[, c("bin") := findInterval(seq_len(nrow(DT)), brks)]
    DT2 <- DT[, lapply(.SD, mean, na.rm = TRUE), by = "bin"]
    DT2[, c("bin") := NULL]
    return(as.data.frame(DT2))
}

.gCD_covStats <- function(cov, ribbon_mode) {
    out <- list()
    outnames <- names(cov)
    
    for(i in seq_len(length(cov))) {
        covmat <- as.matrix(cov[[outnames[i]]][,-1])
        out[[outnames[i]]] <- data.frame(
            x = cov[[outnames[i]]]$x,
            mean = rowMeans(covmat)
        )
        n <- ncol(covmat)
        if(ribbon_mode == "sd") {
            out[[outnames[i]]]$var <- rowSds(covmat)
        } else if(ribbon_mode == "sem") {
            out[[outnames[i]]]$var <- rowSds(covmat) / sqrt(n)
        } else if(ribbon_mode == "ci") {
            conf.int <- 0.95
            out[[outnames[i]]]$var <- qt((1 + conf.int) / 2, df = n - 1) * 
                rowSds(covmat) / sqrt(n)
        }
    }
    return(out)
}

.gCD_ttest <- function(cov1, cov2) {
    coords <- sort(intersect(cov1$x, cov2$x))
    mat <- cbind(as.matrix(
        cov1[cov1$x %in% coords, -1],
        cov2[cov2$x %in% coords, -1]
    ))
    fac <- factor(rep(c("1", "2"), each = c(ncol(cov1) - 1, ncol(cov2) - 1)))
    
    t_test <- genefilter::rowttests(mat, fac)
    
    ret <- data.frame(
        x = coords,
        t_stat = -log10(t_test$p.value)
    )
    ret$t_stat[!is.finite(ret$t_stat)] <- 0
    return(ret)
}

.gCD_getPSI <- function(obj, args, norm_cov) {
    view_chr <- args[["view_chr"]]
    view_start <- args[["view_start"]]
    view_end <- args[["view_end"]]
    view_strand_jn <- args[["view_strand_jn"]]

    outList <- list()
    sampleList <- args[["sampleList"]]

    gr_select <- GRanges(
        view_chr, 
        IRanges(view_start, view_end), 
        view_strand_jn
    )
    OL <- findOverlaps(obj@juncData$junc_gr, gr_select)
        
    if(length(unique(from(OL))) == 0) return(NULL)

    hits <- sort(unique(from(OL)))
    junc_gr <- obj@juncData$junc_gr[hits]
    leftCoords <- start(junc_gr) - 1
    rightCoords <- end(junc_gr) + 1
    lC_inrange <- leftCoords >= view_start & leftCoords <= view_end
    rC_inrange <- rightCoords >= view_start & rightCoords <= view_end

    # normalize by starting coordinates:

    for(i in seq_len(length(sampleList))) {
        track <- names(sampleList)[i]
        samples <- sampleList[[i]]
        
        junc <- obj@juncData$junc_PSI[hits, samples, drop = FALSE]
        
        # Returned data
        outList[[track]] <- .grDT(cbind(
            as.data.frame(junc_gr),
            data.frame(
                mean = rowMeans(junc),
                sd = rowSds(junc),
                leftCoordHeight = 1,
                rightCoordHeight = 1
            )
        ), keep.extra.columns = TRUE)
        
        cov <- norm_cov[[track]]
        
        if(sum(lC_inrange) > 0) {
            covL <- cov[leftCoords[lC_inrange] - cov$x[1] + 1, -1]
            mcols(outList[[track]])$leftCoordHeight[lC_inrange] <- rowMeans(covL)
        }
            
        if(sum(rC_inrange) > 0) {
            covR <- cov[rightCoords[rC_inrange] - cov$x[1] + 1, -1]
            mcols(outList[[track]])$rightCoordHeight[rC_inrange] <- rowMeans(covR)
        }
    }
    return(outList)
}

.gCD_getJuncRaw <- function(obj, args, raw_cov) {
    view_chr <- args[["view_chr"]]
    view_start <- args[["view_start"]]
    view_end <- args[["view_end"]]
    view_strand_jn <- args[["view_strand_jn"]]

    outList <- list()
    sampleList <- args[["sampleList"]]

    gr_select <- GRanges(
        view_chr, 
        IRanges(view_start, view_end), 
        view_strand_jn
    )
    OL <- findOverlaps(obj@juncData$junc_gr, gr_select)
        
    if(length(unique(from(OL))) == 0) return(NULL)

    hits <- sort(unique(from(OL)))
    junc_gr <- obj@juncData$junc_gr[hits]
    leftCoords <- start(junc_gr) - 1
    rightCoords <- end(junc_gr) + 1
    lC_inrange <- leftCoords >= view_start & leftCoords <= view_end
    rC_inrange <- rightCoords >= view_start & rightCoords <= view_end

    # normalize by starting coordinates:

    for(i in seq_len(length(sampleList))) {
        track <- names(sampleList)[i]
        samples <- sampleList[[i]]
        
        if(view_strand_jn == "*") {
            junc <- obj@juncData$junc_counts_uns[hits, samples, drop = FALSE]
        } else {
            junc <- obj@juncData$junc_counts[hits, samples, drop = FALSE]            
        }
        
        cov <- raw_cov[[track]]

        # Returned data
        outList[[track]] <- .grDT(cbind(
            as.data.frame(junc_gr),
            data.frame(
                count = unname(unlist(junc)),
                leftCoordHeight = max(cov[,2]),
                rightCoordHeight = max(cov[,2])
            )
        ), keep.extra.columns = TRUE)

        if(sum(lC_inrange) > 0) {
            covL <- cov[leftCoords[lC_inrange] - cov$x[1] + 1, -1]
            mcols(outList[[track]])$leftCoordHeight[lC_inrange] <- covL
        }
        if(sum(rC_inrange) > 0) {
            covR <- cov[rightCoords[rC_inrange] - cov$x[1] + 1, -1]
            mcols(outList[[track]])$rightCoordHeight[rC_inrange] <- covR
        }
    }
    return(outList)
}

